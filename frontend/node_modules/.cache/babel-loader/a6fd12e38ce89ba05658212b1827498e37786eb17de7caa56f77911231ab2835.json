{"ast":null,"code":"import { applyUnfilter } from './applyUnfilter';\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\n/**\n * Decodes the Adam7 interlaced PNG data.\n *\n * @param params - DecodeInterlaceNullParams\n * @returns - array of pixel data.\n */\nexport function decodeInterlaceAdam7(params) {\n  const {\n    data,\n    width,\n    height,\n    channels,\n    depth\n  } = params;\n  // Adam7 interlacing pattern\n  const passes = [{\n    x: 0,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  },\n  // Pass 1\n  {\n    x: 4,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  },\n  // Pass 2\n  {\n    x: 0,\n    y: 4,\n    xStep: 4,\n    yStep: 8\n  },\n  // Pass 3\n  {\n    x: 2,\n    y: 0,\n    xStep: 4,\n    yStep: 4\n  },\n  // Pass 4\n  {\n    x: 0,\n    y: 2,\n    xStep: 2,\n    yStep: 4\n  },\n  // Pass 5\n  {\n    x: 1,\n    y: 0,\n    xStep: 2,\n    yStep: 2\n  },\n  // Pass 6\n  {\n    x: 0,\n    y: 1,\n    xStep: 1,\n    yStep: 2\n  } // Pass 7\n  ];\n  const bytesPerPixel = Math.ceil(depth / 8) * channels;\n  const resultData = new Uint8Array(height * width * bytesPerPixel);\n  let offset = 0;\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    // Calculate pass dimensions\n    const passWidth = Math.ceil((width - pass.x) / pass.xStep);\n    const passHeight = Math.ceil((height - pass.y) / pass.yStep);\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * bytesPerPixel;\n    const prevLine = new Uint8Array(passLineBytes);\n    // Process each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      // First byte is the filter type\n      const filterType = data[offset++];\n      const currentLine = data.subarray(offset, offset + passLineBytes);\n      offset += passLineBytes;\n      // Create a new line for the unfiltered data\n      const newLine = new Uint8Array(passLineBytes);\n      // Apply the appropriate unfilter\n      applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n      prevLine.set(newLine);\n      for (let x = 0; x < passWidth; x++) {\n        const outputX = pass.x + x * pass.xStep;\n        const outputY = pass.y + y * pass.yStep;\n        if (outputX >= width || outputY >= height) continue;\n        for (let i = 0; i < bytesPerPixel; i++) {\n          resultData[(outputY * width + outputX) * bytesPerPixel + i] = newLine[x * bytesPerPixel + i];\n        }\n      }\n    }\n  }\n  if (depth === 16) {\n    const uint16Data = new Uint16Array(resultData.buffer);\n    if (osIsLittleEndian) {\n      for (let k = 0; k < uint16Data.length; k++) {\n        // PNG is always big endian. Swap the bytes.\n        uint16Data[k] = swap16(uint16Data[k]);\n      }\n    }\n    return uint16Data;\n  } else {\n    return resultData;\n  }\n}\nfunction swap16(val) {\n  return (val & 0xff) << 8 | val >> 8 & 0xff;\n}\n//# sourceMappingURL=decodeInterlaceAdam7.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}