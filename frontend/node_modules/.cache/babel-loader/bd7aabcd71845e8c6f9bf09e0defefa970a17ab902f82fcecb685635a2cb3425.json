{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define([], e) : \"object\" == typeof exports ? exports.Wavoip = e() : t.Wavoip = e();\n}(window, function () {\n  return function (t) {\n    var e = {};\n    function r(n) {\n      if (e[n]) return e[n].exports;\n      var o = e[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;\n    }\n    return r.m = t, r.c = e, r.d = function (t, e, n) {\n      r.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: n\n      });\n    }, r.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, r.t = function (t, e) {\n      if (1 & e && (t = r(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var n = Object.create(null);\n      if (r.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var o in t) r.d(n, o, function (e) {\n        return t[e];\n      }.bind(null, o));\n      return n;\n    }, r.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return r.d(e, \"a\", e), e;\n    }, r.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, r.p = \"\", r(r.s = 21);\n  }([function (t, e, r) {\n    \"use strict\";\n\n    (function (t) {\n      var n = r(12);\n      const {\n          toString: o\n        } = Object.prototype,\n        {\n          getPrototypeOf: i\n        } = Object,\n        s = (a = Object.create(null), t => {\n          const e = o.call(t);\n          return a[e] || (a[e] = e.slice(8, -1).toLowerCase());\n        });\n      var a;\n      const c = t => (t = t.toLowerCase(), e => s(e) === t),\n        u = t => e => typeof e === t,\n        {\n          isArray: h\n        } = Array,\n        f = u(\"undefined\");\n      const l = c(\"ArrayBuffer\");\n      const p = u(\"string\"),\n        d = u(\"function\"),\n        y = u(\"number\"),\n        m = t => null !== t && \"object\" == typeof t,\n        g = t => {\n          if (\"object\" !== s(t)) return !1;\n          const e = i(t);\n          return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || Symbol.toStringTag in t || Symbol.iterator in t);\n        },\n        v = c(\"Date\"),\n        b = c(\"File\"),\n        w = c(\"Blob\"),\n        E = c(\"FileList\"),\n        _ = c(\"URLSearchParams\");\n      function O(t, e) {\n        let {\n          allOwnKeys: r = !1\n        } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (null == t) return;\n        let n, o;\n        if (\"object\" != typeof t && (t = [t]), h(t)) for (n = 0, o = t.length; n < o; n++) e.call(null, t[n], n, t);else {\n          const o = r ? Object.getOwnPropertyNames(t) : Object.keys(t),\n            i = o.length;\n          let s;\n          for (n = 0; n < i; n++) s = o[n], e.call(null, t[s], s, t);\n        }\n      }\n      function S(t, e) {\n        e = e.toLowerCase();\n        const r = Object.keys(t);\n        let n,\n          o = r.length;\n        for (; o-- > 0;) if (n = r[o], e === n.toLowerCase()) return n;\n        return null;\n      }\n      const k = \"undefined\" == typeof self ? void 0 === t ? void 0 : t : self,\n        A = t => !f(t) && t !== k;\n      const R = (x = \"undefined\" != typeof Uint8Array && i(Uint8Array), t => x && t instanceof x);\n      var x;\n      const T = c(\"HTMLFormElement\"),\n        P = (_ref => {\n          let {\n            hasOwnProperty: t\n          } = _ref;\n          return (e, r) => t.call(e, r);\n        })(Object.prototype),\n        j = c(\"RegExp\"),\n        C = (t, e) => {\n          const r = Object.getOwnPropertyDescriptors(t),\n            n = {};\n          O(r, (r, o) => {\n            !1 !== e(r, o, t) && (n[o] = r);\n          }), Object.defineProperties(t, n);\n        };\n      e.a = {\n        isArray: h,\n        isArrayBuffer: l,\n        isBuffer: function (t) {\n          return null !== t && !f(t) && null !== t.constructor && !f(t.constructor) && d(t.constructor.isBuffer) && t.constructor.isBuffer(t);\n        },\n        isFormData: t => t && (\"function\" == typeof FormData && t instanceof FormData || \"[object FormData]\" === o.call(t) || d(t.toString) && \"[object FormData]\" === t.toString()),\n        isArrayBufferView: function (t) {\n          let e;\n          return e = \"undefined\" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && l(t.buffer), e;\n        },\n        isString: p,\n        isNumber: y,\n        isBoolean: t => !0 === t || !1 === t,\n        isObject: m,\n        isPlainObject: g,\n        isUndefined: f,\n        isDate: v,\n        isFile: b,\n        isBlob: w,\n        isRegExp: j,\n        isFunction: d,\n        isStream: t => m(t) && d(t.pipe),\n        isURLSearchParams: _,\n        isTypedArray: R,\n        isFileList: E,\n        forEach: O,\n        merge: function t() {\n          const {\n              caseless: e\n            } = A(this) && this || {},\n            r = {},\n            n = (n, o) => {\n              const i = e && S(r, o) || o;\n              g(r[i]) && g(n) ? r[i] = t(r[i], n) : g(n) ? r[i] = t({}, n) : h(n) ? r[i] = n.slice() : r[i] = n;\n            };\n          for (let t = 0, e = arguments.length; t < e; t++) arguments[t] && O(arguments[t], n);\n          return r;\n        },\n        extend: function (t, e, r) {\n          let {\n            allOwnKeys: o\n          } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          return O(e, (e, o) => {\n            r && d(e) ? t[o] = Object(n.a)(e, r) : t[o] = e;\n          }, {\n            allOwnKeys: o\n          }), t;\n        },\n        trim: t => t.trim ? t.trim() : t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\"),\n        stripBOM: t => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),\n        inherits: (t, e, r, n) => {\n          t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, \"super\", {\n            value: e.prototype\n          }), r && Object.assign(t.prototype, r);\n        },\n        toFlatObject: (t, e, r, n) => {\n          let o, s, a;\n          const c = {};\n          if (e = e || {}, null == t) return e;\n          do {\n            for (o = Object.getOwnPropertyNames(t), s = o.length; s-- > 0;) a = o[s], n && !n(a, t, e) || c[a] || (e[a] = t[a], c[a] = !0);\n            t = !1 !== r && i(t);\n          } while (t && (!r || r(t, e)) && t !== Object.prototype);\n          return e;\n        },\n        kindOf: s,\n        kindOfTest: c,\n        endsWith: (t, e, r) => {\n          t = String(t), (void 0 === r || r > t.length) && (r = t.length), r -= e.length;\n          const n = t.indexOf(e, r);\n          return -1 !== n && n === r;\n        },\n        toArray: t => {\n          if (!t) return null;\n          if (h(t)) return t;\n          let e = t.length;\n          if (!y(e)) return null;\n          const r = new Array(e);\n          for (; e-- > 0;) r[e] = t[e];\n          return r;\n        },\n        forEachEntry: (t, e) => {\n          const r = (t && t[Symbol.iterator]).call(t);\n          let n;\n          for (; (n = r.next()) && !n.done;) {\n            const r = n.value;\n            e.call(t, r[0], r[1]);\n          }\n        },\n        matchAll: (t, e) => {\n          let r;\n          const n = [];\n          for (; null !== (r = t.exec(e));) n.push(r);\n          return n;\n        },\n        isHTMLForm: T,\n        hasOwnProperty: P,\n        hasOwnProp: P,\n        reduceDescriptors: C,\n        freezeMethods: t => {\n          C(t, (e, r) => {\n            if (d(t) && -1 !== [\"arguments\", \"caller\", \"callee\"].indexOf(r)) return !1;\n            const n = t[r];\n            d(n) && (e.enumerable = !1, \"writable\" in e ? e.writable = !1 : e.set || (e.set = () => {\n              throw Error(\"Can not rewrite read-only method '\" + r + \"'\");\n            }));\n          });\n        },\n        toObjectSet: (t, e) => {\n          const r = {},\n            n = t => {\n              t.forEach(t => {\n                r[t] = !0;\n              });\n            };\n          return h(t) ? n(t) : n(String(t).split(e)), r;\n        },\n        toCamelCase: t => t.toLowerCase().replace(/[_-\\s]([a-z\\d])(\\w*)/g, function (t, e, r) {\n          return e.toUpperCase() + r;\n        }),\n        noop: () => {},\n        toFiniteNumber: (t, e) => (t = +t, Number.isFinite(t) ? t : e),\n        findKey: S,\n        global: k,\n        isContextDefined: A,\n        toJSONObject: t => {\n          const e = new Array(10),\n            r = (t, n) => {\n              if (m(t)) {\n                if (e.indexOf(t) >= 0) return;\n                if (!(\"toJSON\" in t)) {\n                  e[n] = t;\n                  const o = h(t) ? [] : {};\n                  return O(t, (t, e) => {\n                    const i = r(t, n + 1);\n                    !f(i) && (o[e] = i);\n                  }), e[n] = void 0, o;\n                }\n              }\n              return t;\n            };\n          return r(t, 0);\n        }\n      };\n    }).call(this, r(14));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var n = r(0);\n    function o(t, e, r, n, o) {\n      Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = \"AxiosError\", e && (this.code = e), r && (this.config = r), n && (this.request = n), o && (this.response = o);\n    }\n    n.a.inherits(o, Error, {\n      toJSON: function () {\n        return {\n          message: this.message,\n          name: this.name,\n          description: this.description,\n          number: this.number,\n          fileName: this.fileName,\n          lineNumber: this.lineNumber,\n          columnNumber: this.columnNumber,\n          stack: this.stack,\n          config: n.a.toJSONObject(this.config),\n          code: this.code,\n          status: this.response && this.response.status ? this.response.status : null\n        };\n      }\n    });\n    const i = o.prototype,\n      s = {};\n    [\"ERR_BAD_OPTION_VALUE\", \"ERR_BAD_OPTION\", \"ECONNABORTED\", \"ETIMEDOUT\", \"ERR_NETWORK\", \"ERR_FR_TOO_MANY_REDIRECTS\", \"ERR_DEPRECATED\", \"ERR_BAD_RESPONSE\", \"ERR_BAD_REQUEST\", \"ERR_CANCELED\", \"ERR_NOT_SUPPORT\", \"ERR_INVALID_URL\"].forEach(t => {\n      s[t] = {\n        value: t\n      };\n    }), Object.defineProperties(o, s), Object.defineProperty(i, \"isAxiosError\", {\n      value: !0\n    }), o.from = (t, e, r, s, a, c) => {\n      const u = Object.create(i);\n      return n.a.toFlatObject(t, u, function (t) {\n        return t !== Error.prototype;\n      }, t => \"isAxiosError\" !== t), o.call(u, t.message, e, r, s, a), u.cause = t, u.name = t.name, c && Object.assign(u, c), u;\n    }, e.a = o;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return n;\n    });\n    const n = \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : Function(\"return this\")();\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function n(t) {\n      if (t) return function (t) {\n        for (var e in n.prototype) t[e] = n.prototype[e];\n        return t;\n      }(t);\n    }\n    r.d(e, \"a\", function () {\n      return n;\n    }), n.prototype.on = n.prototype.addEventListener = function (t, e) {\n      return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + t] = this._callbacks[\"$\" + t] || []).push(e), this;\n    }, n.prototype.once = function (t, e) {\n      function r() {\n        this.off(t, r), e.apply(this, arguments);\n      }\n      return r.fn = e, this.on(t, r), this;\n    }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function (t, e) {\n      if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;\n      var r,\n        n = this._callbacks[\"$\" + t];\n      if (!n) return this;\n      if (1 == arguments.length) return delete this._callbacks[\"$\" + t], this;\n      for (var o = 0; o < n.length; o++) if ((r = n[o]) === e || r.fn === e) {\n        n.splice(o, 1);\n        break;\n      }\n      return 0 === n.length && delete this._callbacks[\"$\" + t], this;\n    }, n.prototype.emit = function (t) {\n      this._callbacks = this._callbacks || {};\n      for (var e = new Array(arguments.length - 1), r = this._callbacks[\"$\" + t], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n      if (r) {\n        n = 0;\n        for (var o = (r = r.slice(0)).length; n < o; ++n) r[n].apply(this, e);\n      }\n      return this;\n    }, n.prototype.emitReserved = n.prototype.emit, n.prototype.listeners = function (t) {\n      return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + t] || [];\n    }, n.prototype.hasListeners = function (t) {\n      return !!this.listeners(t).length;\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"c\", function () {\n      return o;\n    }), r.d(e, \"b\", function () {\n      return a;\n    }), r.d(e, \"a\", function () {\n      return c;\n    });\n    var n = r(2);\n    function o(t) {\n      for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        e[_key - 1] = arguments[_key];\n      }\n      return e.reduce((e, r) => (t.hasOwnProperty(r) && (e[r] = t[r]), e), {});\n    }\n    const i = n.a.setTimeout,\n      s = n.a.clearTimeout;\n    function a(t, e) {\n      e.useNativeTimers ? (t.setTimeoutFn = i.bind(n.a), t.clearTimeoutFn = s.bind(n.a)) : (t.setTimeoutFn = n.a.setTimeout.bind(n.a), t.clearTimeoutFn = n.a.clearTimeout.bind(n.a));\n    }\n    function c(t) {\n      return \"string\" == typeof t ? function (t) {\n        let e = 0,\n          r = 0;\n        for (let n = 0, o = t.length; n < o; n++) e = t.charCodeAt(n), e < 128 ? r += 1 : e < 2048 ? r += 2 : e < 55296 || e >= 57344 ? r += 3 : (n++, r += 4);\n        return r;\n      }(t) : Math.ceil(1.33 * (t.byteLength || t.size));\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"c\", function () {\n      return o;\n    }), r.d(e, \"a\", function () {\n      return i;\n    }), r.d(e, \"d\", function () {\n      return s;\n    }), r.d(e, \"b\", function () {\n      return a;\n    });\n    var n = r(2);\n    const o = \"function\" == typeof Promise && \"function\" == typeof Promise.resolve ? t => Promise.resolve().then(t) : (t, e) => e(t, 0),\n      i = n.a.WebSocket || n.a.MozWebSocket,\n      s = !0,\n      a = \"arraybuffer\";\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"e\", function () {\n      return b;\n    }), r.d(e, \"c\", function () {\n      return u;\n    }), r.d(e, \"d\", function () {\n      return g;\n    }), r.d(e, \"a\", function () {\n      return y;\n    }), r.d(e, \"b\", function () {\n      return v;\n    });\n    const n = Object.create(null);\n    n.open = \"0\", n.close = \"1\", n.ping = \"2\", n.pong = \"3\", n.message = \"4\", n.upgrade = \"5\", n.noop = \"6\";\n    const o = Object.create(null);\n    Object.keys(n).forEach(t => {\n      o[n[t]] = t;\n    });\n    const i = {\n        type: \"error\",\n        data: \"parser error\"\n      },\n      s = \"function\" == typeof Blob || \"undefined\" != typeof Blob && \"[object BlobConstructor]\" === Object.prototype.toString.call(Blob),\n      a = \"function\" == typeof ArrayBuffer,\n      c = (t, e) => {\n        const r = new FileReader();\n        return r.onload = function () {\n          const t = r.result.split(\",\")[1];\n          e(\"b\" + (t || \"\"));\n        }, r.readAsDataURL(t);\n      };\n    var u = (_ref2, r, o) => {\n      let {\n        type: t,\n        data: e\n      } = _ref2;\n      return s && e instanceof Blob ? r ? o(e) : c(e, o) : a && (e instanceof ArrayBuffer || (i = e, \"function\" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer)) ? r ? o(e) : c(new Blob([e]), o) : o(n[t] + (e || \"\"));\n      var i;\n    };\n    const h = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n      f = \"undefined\" == typeof Uint8Array ? [] : new Uint8Array(256);\n    for (let t = 0; t < h.length; t++) f[h.charCodeAt(t)] = t;\n    const l = \"function\" == typeof ArrayBuffer,\n      p = (t, e) => {\n        if (l) {\n          const r = (t => {\n            let e,\n              r,\n              n,\n              o,\n              i,\n              s = .75 * t.length,\n              a = t.length,\n              c = 0;\n            \"=\" === t[t.length - 1] && (s--, \"=\" === t[t.length - 2] && s--);\n            const u = new ArrayBuffer(s),\n              h = new Uint8Array(u);\n            for (e = 0; e < a; e += 4) r = f[t.charCodeAt(e)], n = f[t.charCodeAt(e + 1)], o = f[t.charCodeAt(e + 2)], i = f[t.charCodeAt(e + 3)], h[c++] = r << 2 | n >> 4, h[c++] = (15 & n) << 4 | o >> 2, h[c++] = (3 & o) << 6 | 63 & i;\n            return u;\n          })(t);\n          return d(r, e);\n        }\n        return {\n          base64: !0,\n          data: t\n        };\n      },\n      d = (t, e) => {\n        switch (e) {\n          case \"blob\":\n            return t instanceof ArrayBuffer ? new Blob([t]) : t;\n          case \"arraybuffer\":\n          default:\n            return t;\n        }\n      };\n    var y = (t, e) => {\n      if (\"string\" != typeof t) return {\n        type: \"message\",\n        data: d(t, e)\n      };\n      const r = t.charAt(0);\n      if (\"b\" === r) return {\n        type: \"message\",\n        data: p(t.substring(1), e)\n      };\n      return o[r] ? t.length > 1 ? {\n        type: o[r],\n        data: t.substring(1)\n      } : {\n        type: o[r]\n      } : i;\n    };\n    const m = String.fromCharCode(30),\n      g = (t, e) => {\n        const r = t.length,\n          n = new Array(r);\n        let o = 0;\n        t.forEach((t, i) => {\n          u(t, !1, t => {\n            n[i] = t, ++o === r && e(n.join(m));\n          });\n        });\n      },\n      v = (t, e) => {\n        const r = t.split(m),\n          n = [];\n        for (let t = 0; t < r.length; t++) {\n          const o = y(r[t], e);\n          if (n.push(o), \"error\" === o.type) break;\n        }\n        return n;\n      },\n      b = 4;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    (function (t) {\n      var n = r(0),\n        o = r(1),\n        i = r(18);\n      function s(t) {\n        return n.a.isPlainObject(t) || n.a.isArray(t);\n      }\n      function a(t) {\n        return n.a.endsWith(t, \"[]\") ? t.slice(0, -2) : t;\n      }\n      function c(t, e, r) {\n        return t ? t.concat(e).map(function (t, e) {\n          return t = a(t), !r && e ? \"[\" + t + \"]\" : t;\n        }).join(r ? \".\" : \"\") : e;\n      }\n      const u = n.a.toFlatObject(n.a, {}, null, function (t) {\n        return /^is[A-Z]/.test(t);\n      });\n      e.a = function (e, r, h) {\n        if (!n.a.isObject(e)) throw new TypeError(\"target must be an object\");\n        r = r || new (i.a || FormData)();\n        const f = (h = n.a.toFlatObject(h, {\n            metaTokens: !0,\n            dots: !1,\n            indexes: !1\n          }, !1, function (t, e) {\n            return !n.a.isUndefined(e[t]);\n          })).metaTokens,\n          l = h.visitor || v,\n          p = h.dots,\n          d = h.indexes,\n          y = (h.Blob || \"undefined\" != typeof Blob && Blob) && (m = r) && n.a.isFunction(m.append) && \"FormData\" === m[Symbol.toStringTag] && m[Symbol.iterator];\n        var m;\n        if (!n.a.isFunction(l)) throw new TypeError(\"visitor must be a function\");\n        function g(e) {\n          if (null === e) return \"\";\n          if (n.a.isDate(e)) return e.toISOString();\n          if (!y && n.a.isBlob(e)) throw new o.a(\"Blob is not supported. Use a Buffer instead.\");\n          return n.a.isArrayBuffer(e) || n.a.isTypedArray(e) ? y && \"function\" == typeof Blob ? new Blob([e]) : t.from(e) : e;\n        }\n        function v(t, e, o) {\n          let i = t;\n          if (t && !o && \"object\" == typeof t) if (n.a.endsWith(e, \"{}\")) e = f ? e : e.slice(0, -2), t = JSON.stringify(t);else if (n.a.isArray(t) && function (t) {\n            return n.a.isArray(t) && !t.some(s);\n          }(t) || n.a.isFileList(t) || n.a.endsWith(e, \"[]\") && (i = n.a.toArray(t))) return e = a(e), i.forEach(function (t, o) {\n            !n.a.isUndefined(t) && null !== t && r.append(!0 === d ? c([e], o, p) : null === d ? e : e + \"[]\", g(t));\n          }), !1;\n          return !!s(t) || (r.append(c(o, e, p), g(t)), !1);\n        }\n        const b = [],\n          w = Object.assign(u, {\n            defaultVisitor: v,\n            convertValue: g,\n            isVisitable: s\n          });\n        if (!n.a.isObject(e)) throw new TypeError(\"data must be an object\");\n        return function t(e, o) {\n          if (!n.a.isUndefined(e)) {\n            if (-1 !== b.indexOf(e)) throw Error(\"Circular reference detected in \" + o.join(\".\"));\n            b.push(e), n.a.forEach(e, function (e, i) {\n              !0 === (!(n.a.isUndefined(e) || null === e) && l.call(r, e, n.a.isString(i) ? i.trim() : i, o, w)) && t(e, o ? o.concat(i) : [i]);\n            }), b.pop();\n          }\n        }(e), r;\n      };\n    }).call(this, r(13).Buffer);\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return a;\n    });\n    var n = r(6),\n      o = r(3),\n      i = r(4);\n    class s extends Error {\n      constructor(t, e, r) {\n        super(t), this.description = e, this.context = r, this.type = \"TransportError\";\n      }\n    }\n    class a extends o.a {\n      constructor(t) {\n        super(), this.writable = !1, Object(i.b)(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;\n      }\n      onError(t, e, r) {\n        return super.emitReserved(\"error\", new s(t, e, r)), this;\n      }\n      open() {\n        return this.readyState = \"opening\", this.doOpen(), this;\n      }\n      close() {\n        return \"opening\" !== this.readyState && \"open\" !== this.readyState || (this.doClose(), this.onClose()), this;\n      }\n      send(t) {\n        \"open\" === this.readyState && this.write(t);\n      }\n      onOpen() {\n        this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n      }\n      onData(t) {\n        const e = Object(n.a)(t, this.socket.binaryType);\n        this.onPacket(e);\n      }\n      onPacket(t) {\n        super.emitReserved(\"packet\", t);\n      }\n      onClose(t) {\n        this.readyState = \"closed\", super.emitReserved(\"close\", t);\n      }\n      pause(t) {}\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function n(t) {\n      let e = \"\";\n      for (let r in t) t.hasOwnProperty(r) && (e.length && (e += \"&\"), e += encodeURIComponent(r) + \"=\" + encodeURIComponent(t[r]));\n      return e;\n    }\n    function o(t) {\n      let e = {},\n        r = t.split(\"&\");\n      for (let t = 0, n = r.length; t < n; t++) {\n        let n = r[t].split(\"=\");\n        e[decodeURIComponent(n[0])] = decodeURIComponent(n[1]);\n      }\n      return e;\n    }\n    r.d(e, \"b\", function () {\n      return n;\n    }), r.d(e, \"a\", function () {\n      return o;\n    });\n  },, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return u;\n    });\n    const n = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"),\n      o = {};\n    let i,\n      s = 0,\n      a = 0;\n    function c(t) {\n      let e = \"\";\n      do {\n        e = n[t % 64] + e, t = Math.floor(t / 64);\n      } while (t > 0);\n      return e;\n    }\n    function u() {\n      const t = c(+new Date());\n      return t !== i ? (s = 0, i = t) : t + \".\" + c(s++);\n    }\n    for (; a < 64; a++) o[n[a]] = a;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function n(t, e) {\n      return function () {\n        return t.apply(e, arguments);\n      };\n    }\n    r.d(e, \"a\", function () {\n      return n;\n    });\n  }, function (t, e, r) {\n    \"use strict\";\n\n    (function (t) {\n      /*!\n       * The buffer module from node.js, for the browser.\n       *\n       * @author   Feross Aboukhadijeh <http://feross.org>\n       * @license  MIT\n       */\n      var n = r(22),\n        o = r(23),\n        i = r(24);\n      function s() {\n        return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\n      }\n      function a(t, e) {\n        if (s() < e) throw new RangeError(\"Invalid typed array length\");\n        return c.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = c.prototype : (null === t && (t = new c(e)), t.length = e), t;\n      }\n      function c(t, e, r) {\n        if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c)) return new c(t, e, r);\n        if (\"number\" == typeof t) {\n          if (\"string\" == typeof e) throw new Error(\"If encoding is specified then the first argument must be a string\");\n          return f(this, t);\n        }\n        return u(this, t, e, r);\n      }\n      function u(t, e, r, n) {\n        if (\"number\" == typeof e) throw new TypeError('\"value\" argument must not be a number');\n        return \"undefined\" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, r, n) {\n          if (e.byteLength, r < 0 || e.byteLength < r) throw new RangeError(\"'offset' is out of bounds\");\n          if (e.byteLength < r + (n || 0)) throw new RangeError(\"'length' is out of bounds\");\n          e = void 0 === r && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, r) : new Uint8Array(e, r, n);\n          c.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = c.prototype : t = l(t, e);\n          return t;\n        }(t, e, r, n) : \"string\" == typeof e ? function (t, e, r) {\n          \"string\" == typeof r && \"\" !== r || (r = \"utf8\");\n          if (!c.isEncoding(r)) throw new TypeError('\"encoding\" must be a valid string encoding');\n          var n = 0 | d(e, r),\n            o = (t = a(t, n)).write(e, r);\n          o !== n && (t = t.slice(0, o));\n          return t;\n        }(t, e, r) : function (t, e) {\n          if (c.isBuffer(e)) {\n            var r = 0 | p(e.length);\n            return 0 === (t = a(t, r)).length || e.copy(t, 0, 0, r), t;\n          }\n          if (e) {\n            if (\"undefined\" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || \"length\" in e) return \"number\" != typeof e.length || (n = e.length) != n ? a(t, 0) : l(t, e);\n            if (\"Buffer\" === e.type && i(e.data)) return l(t, e.data);\n          }\n          var n;\n          throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n        }(t, e);\n      }\n      function h(t) {\n        if (\"number\" != typeof t) throw new TypeError('\"size\" argument must be a number');\n        if (t < 0) throw new RangeError('\"size\" argument must not be negative');\n      }\n      function f(t, e) {\n        if (h(e), t = a(t, e < 0 ? 0 : 0 | p(e)), !c.TYPED_ARRAY_SUPPORT) for (var r = 0; r < e; ++r) t[r] = 0;\n        return t;\n      }\n      function l(t, e) {\n        var r = e.length < 0 ? 0 : 0 | p(e.length);\n        t = a(t, r);\n        for (var n = 0; n < r; n += 1) t[n] = 255 & e[n];\n        return t;\n      }\n      function p(t) {\n        if (t >= s()) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + s().toString(16) + \" bytes\");\n        return 0 | t;\n      }\n      function d(t, e) {\n        if (c.isBuffer(t)) return t.length;\n        if (\"undefined\" != typeof ArrayBuffer && \"function\" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;\n        \"string\" != typeof t && (t = \"\" + t);\n        var r = t.length;\n        if (0 === r) return 0;\n        for (var n = !1;;) switch (e) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return r;\n          case \"utf8\":\n          case \"utf-8\":\n          case void 0:\n            return F(t).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return 2 * r;\n          case \"hex\":\n            return r >>> 1;\n          case \"base64\":\n            return q(t).length;\n          default:\n            if (n) return F(t).length;\n            e = (\"\" + e).toLowerCase(), n = !0;\n        }\n      }\n      function y(t, e, r) {\n        var n = !1;\n        if ((void 0 === e || e < 0) && (e = 0), e > this.length) return \"\";\n        if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return \"\";\n        if ((r >>>= 0) <= (e >>>= 0)) return \"\";\n        for (t || (t = \"utf8\");;) switch (t) {\n          case \"hex\":\n            return T(this, e, r);\n          case \"utf8\":\n          case \"utf-8\":\n            return A(this, e, r);\n          case \"ascii\":\n            return R(this, e, r);\n          case \"latin1\":\n          case \"binary\":\n            return x(this, e, r);\n          case \"base64\":\n            return k(this, e, r);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return P(this, e, r);\n          default:\n            if (n) throw new TypeError(\"Unknown encoding: \" + t);\n            t = (t + \"\").toLowerCase(), n = !0;\n        }\n      }\n      function m(t, e, r) {\n        var n = t[e];\n        t[e] = t[r], t[r] = n;\n      }\n      function g(t, e, r, n, o) {\n        if (0 === t.length) return -1;\n        if (\"string\" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = o ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {\n          if (o) return -1;\n          r = t.length - 1;\n        } else if (r < 0) {\n          if (!o) return -1;\n          r = 0;\n        }\n        if (\"string\" == typeof e && (e = c.from(e, n)), c.isBuffer(e)) return 0 === e.length ? -1 : v(t, e, r, n, o);\n        if (\"number\" == typeof e) return e &= 255, c.TYPED_ARRAY_SUPPORT && \"function\" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : v(t, [e], r, n, o);\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function v(t, e, r, n, o) {\n        var i,\n          s = 1,\n          a = t.length,\n          c = e.length;\n        if (void 0 !== n && (\"ucs2\" === (n = String(n).toLowerCase()) || \"ucs-2\" === n || \"utf16le\" === n || \"utf-16le\" === n)) {\n          if (t.length < 2 || e.length < 2) return -1;\n          s = 2, a /= 2, c /= 2, r /= 2;\n        }\n        function u(t, e) {\n          return 1 === s ? t[e] : t.readUInt16BE(e * s);\n        }\n        if (o) {\n          var h = -1;\n          for (i = r; i < a; i++) if (u(t, i) === u(e, -1 === h ? 0 : i - h)) {\n            if (-1 === h && (h = i), i - h + 1 === c) return h * s;\n          } else -1 !== h && (i -= i - h), h = -1;\n        } else for (r + c > a && (r = a - c), i = r; i >= 0; i--) {\n          for (var f = !0, l = 0; l < c; l++) if (u(t, i + l) !== u(e, l)) {\n            f = !1;\n            break;\n          }\n          if (f) return i;\n        }\n        return -1;\n      }\n      function b(t, e, r, n) {\n        r = Number(r) || 0;\n        var o = t.length - r;\n        n ? (n = Number(n)) > o && (n = o) : n = o;\n        var i = e.length;\n        if (i % 2 != 0) throw new TypeError(\"Invalid hex string\");\n        n > i / 2 && (n = i / 2);\n        for (var s = 0; s < n; ++s) {\n          var a = parseInt(e.substr(2 * s, 2), 16);\n          if (isNaN(a)) return s;\n          t[r + s] = a;\n        }\n        return s;\n      }\n      function w(t, e, r, n) {\n        return Y(F(e, t.length - r), t, r, n);\n      }\n      function E(t, e, r, n) {\n        return Y(function (t) {\n          for (var e = [], r = 0; r < t.length; ++r) e.push(255 & t.charCodeAt(r));\n          return e;\n        }(e), t, r, n);\n      }\n      function _(t, e, r, n) {\n        return E(t, e, r, n);\n      }\n      function O(t, e, r, n) {\n        return Y(q(e), t, r, n);\n      }\n      function S(t, e, r, n) {\n        return Y(function (t, e) {\n          for (var r, n, o, i = [], s = 0; s < t.length && !((e -= 2) < 0); ++s) r = t.charCodeAt(s), n = r >> 8, o = r % 256, i.push(o), i.push(n);\n          return i;\n        }(e, t.length - r), t, r, n);\n      }\n      function k(t, e, r) {\n        return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r));\n      }\n      function A(t, e, r) {\n        r = Math.min(t.length, r);\n        for (var n = [], o = e; o < r;) {\n          var i,\n            s,\n            a,\n            c,\n            u = t[o],\n            h = null,\n            f = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;\n          if (o + f <= r) switch (f) {\n            case 1:\n              u < 128 && (h = u);\n              break;\n            case 2:\n              128 == (192 & (i = t[o + 1])) && (c = (31 & u) << 6 | 63 & i) > 127 && (h = c);\n              break;\n            case 3:\n              i = t[o + 1], s = t[o + 2], 128 == (192 & i) && 128 == (192 & s) && (c = (15 & u) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (h = c);\n              break;\n            case 4:\n              i = t[o + 1], s = t[o + 2], a = t[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & a) && (c = (15 & u) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c < 1114112 && (h = c);\n          }\n          null === h ? (h = 65533, f = 1) : h > 65535 && (h -= 65536, n.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), n.push(h), o += f;\n        }\n        return function (t) {\n          var e = t.length;\n          if (e <= 4096) return String.fromCharCode.apply(String, t);\n          var r = \"\",\n            n = 0;\n          for (; n < e;) r += String.fromCharCode.apply(String, t.slice(n, n += 4096));\n          return r;\n        }(n);\n      }\n      e.Buffer = c, e.SlowBuffer = function (t) {\n        +t != t && (t = 0);\n        return c.alloc(+t);\n      }, e.INSPECT_MAX_BYTES = 50, c.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () {\n        try {\n          var t = new Uint8Array(1);\n          return t.__proto__ = {\n            __proto__: Uint8Array.prototype,\n            foo: function () {\n              return 42;\n            }\n          }, 42 === t.foo() && \"function\" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;\n        } catch (t) {\n          return !1;\n        }\n      }(), e.kMaxLength = s(), c.poolSize = 8192, c._augment = function (t) {\n        return t.__proto__ = c.prototype, t;\n      }, c.from = function (t, e, r) {\n        return u(null, t, e, r);\n      }, c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, \"undefined\" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {\n        value: null,\n        configurable: !0\n      })), c.alloc = function (t, e, r) {\n        return function (t, e, r, n) {\n          return h(e), e <= 0 ? a(t, e) : void 0 !== r ? \"string\" == typeof n ? a(t, e).fill(r, n) : a(t, e).fill(r) : a(t, e);\n        }(null, t, e, r);\n      }, c.allocUnsafe = function (t) {\n        return f(null, t);\n      }, c.allocUnsafeSlow = function (t) {\n        return f(null, t);\n      }, c.isBuffer = function (t) {\n        return !(null == t || !t._isBuffer);\n      }, c.compare = function (t, e) {\n        if (!c.isBuffer(t) || !c.isBuffer(e)) throw new TypeError(\"Arguments must be Buffers\");\n        if (t === e) return 0;\n        for (var r = t.length, n = e.length, o = 0, i = Math.min(r, n); o < i; ++o) if (t[o] !== e[o]) {\n          r = t[o], n = e[o];\n          break;\n        }\n        return r < n ? -1 : n < r ? 1 : 0;\n      }, c.isEncoding = function (t) {\n        switch (String(t).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return !0;\n          default:\n            return !1;\n        }\n      }, c.concat = function (t, e) {\n        if (!i(t)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        if (0 === t.length) return c.alloc(0);\n        var r;\n        if (void 0 === e) for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;\n        var n = c.allocUnsafe(e),\n          o = 0;\n        for (r = 0; r < t.length; ++r) {\n          var s = t[r];\n          if (!c.isBuffer(s)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n          s.copy(n, o), o += s.length;\n        }\n        return n;\n      }, c.byteLength = d, c.prototype._isBuffer = !0, c.prototype.swap16 = function () {\n        var t = this.length;\n        if (t % 2 != 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        for (var e = 0; e < t; e += 2) m(this, e, e + 1);\n        return this;\n      }, c.prototype.swap32 = function () {\n        var t = this.length;\n        if (t % 4 != 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        for (var e = 0; e < t; e += 4) m(this, e, e + 3), m(this, e + 1, e + 2);\n        return this;\n      }, c.prototype.swap64 = function () {\n        var t = this.length;\n        if (t % 8 != 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        for (var e = 0; e < t; e += 8) m(this, e, e + 7), m(this, e + 1, e + 6), m(this, e + 2, e + 5), m(this, e + 3, e + 4);\n        return this;\n      }, c.prototype.toString = function () {\n        var t = 0 | this.length;\n        return 0 === t ? \"\" : 0 === arguments.length ? A(this, 0, t) : y.apply(this, arguments);\n      }, c.prototype.equals = function (t) {\n        if (!c.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n        return this === t || 0 === c.compare(this, t);\n      }, c.prototype.inspect = function () {\n        var t = \"\",\n          r = e.INSPECT_MAX_BYTES;\n        return this.length > 0 && (t = this.toString(\"hex\", 0, r).match(/.{2}/g).join(\" \"), this.length > r && (t += \" ... \")), \"<Buffer \" + t + \">\";\n      }, c.prototype.compare = function (t, e, r, n, o) {\n        if (!c.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n        if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === n && (n = 0), void 0 === o && (o = this.length), e < 0 || r > t.length || n < 0 || o > this.length) throw new RangeError(\"out of range index\");\n        if (n >= o && e >= r) return 0;\n        if (n >= o) return -1;\n        if (e >= r) return 1;\n        if (this === t) return 0;\n        for (var i = (o >>>= 0) - (n >>>= 0), s = (r >>>= 0) - (e >>>= 0), a = Math.min(i, s), u = this.slice(n, o), h = t.slice(e, r), f = 0; f < a; ++f) if (u[f] !== h[f]) {\n          i = u[f], s = h[f];\n          break;\n        }\n        return i < s ? -1 : s < i ? 1 : 0;\n      }, c.prototype.includes = function (t, e, r) {\n        return -1 !== this.indexOf(t, e, r);\n      }, c.prototype.indexOf = function (t, e, r) {\n        return g(this, t, e, r, !0);\n      }, c.prototype.lastIndexOf = function (t, e, r) {\n        return g(this, t, e, r, !1);\n      }, c.prototype.write = function (t, e, r, n) {\n        if (void 0 === e) n = \"utf8\", r = this.length, e = 0;else if (void 0 === r && \"string\" == typeof e) n = e, r = this.length, e = 0;else {\n          if (!isFinite(e)) throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n          e |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = \"utf8\")) : (n = r, r = void 0);\n        }\n        var o = this.length - e;\n        if ((void 0 === r || r > o) && (r = o), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n        n || (n = \"utf8\");\n        for (var i = !1;;) switch (n) {\n          case \"hex\":\n            return b(this, t, e, r);\n          case \"utf8\":\n          case \"utf-8\":\n            return w(this, t, e, r);\n          case \"ascii\":\n            return E(this, t, e, r);\n          case \"latin1\":\n          case \"binary\":\n            return _(this, t, e, r);\n          case \"base64\":\n            return O(this, t, e, r);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return S(this, t, e, r);\n          default:\n            if (i) throw new TypeError(\"Unknown encoding: \" + n);\n            n = (\"\" + n).toLowerCase(), i = !0;\n        }\n      }, c.prototype.toJSON = function () {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function R(t, e, r) {\n        var n = \"\";\n        r = Math.min(t.length, r);\n        for (var o = e; o < r; ++o) n += String.fromCharCode(127 & t[o]);\n        return n;\n      }\n      function x(t, e, r) {\n        var n = \"\";\n        r = Math.min(t.length, r);\n        for (var o = e; o < r; ++o) n += String.fromCharCode(t[o]);\n        return n;\n      }\n      function T(t, e, r) {\n        var n = t.length;\n        (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);\n        for (var o = \"\", i = e; i < r; ++i) o += I(t[i]);\n        return o;\n      }\n      function P(t, e, r) {\n        for (var n = t.slice(e, r), o = \"\", i = 0; i < n.length; i += 2) o += String.fromCharCode(n[i] + 256 * n[i + 1]);\n        return o;\n      }\n      function j(t, e, r) {\n        if (t % 1 != 0 || t < 0) throw new RangeError(\"offset is not uint\");\n        if (t + e > r) throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      function C(t, e, r, n, o, i) {\n        if (!c.isBuffer(t)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (e > o || e < i) throw new RangeError('\"value\" argument is out of bounds');\n        if (r + n > t.length) throw new RangeError(\"Index out of range\");\n      }\n      function B(t, e, r, n) {\n        e < 0 && (e = 65535 + e + 1);\n        for (var o = 0, i = Math.min(t.length - r, 2); o < i; ++o) t[r + o] = (e & 255 << 8 * (n ? o : 1 - o)) >>> 8 * (n ? o : 1 - o);\n      }\n      function L(t, e, r, n) {\n        e < 0 && (e = 4294967295 + e + 1);\n        for (var o = 0, i = Math.min(t.length - r, 4); o < i; ++o) t[r + o] = e >>> 8 * (n ? o : 3 - o) & 255;\n      }\n      function N(t, e, r, n, o, i) {\n        if (r + n > t.length) throw new RangeError(\"Index out of range\");\n        if (r < 0) throw new RangeError(\"Index out of range\");\n      }\n      function U(t, e, r, n, i) {\n        return i || N(t, 0, r, 4), o.write(t, e, r, n, 23, 4), r + 4;\n      }\n      function D(t, e, r, n, i) {\n        return i || N(t, 0, r, 8), o.write(t, e, r, n, 52, 8), r + 8;\n      }\n      c.prototype.slice = function (t, e) {\n        var r,\n          n = this.length;\n        if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t), c.TYPED_ARRAY_SUPPORT) (r = this.subarray(t, e)).__proto__ = c.prototype;else {\n          var o = e - t;\n          r = new c(o, void 0);\n          for (var i = 0; i < o; ++i) r[i] = this[i + t];\n        }\n        return r;\n      }, c.prototype.readUIntLE = function (t, e, r) {\n        t |= 0, e |= 0, r || j(t, e, this.length);\n        for (var n = this[t], o = 1, i = 0; ++i < e && (o *= 256);) n += this[t + i] * o;\n        return n;\n      }, c.prototype.readUIntBE = function (t, e, r) {\n        t |= 0, e |= 0, r || j(t, e, this.length);\n        for (var n = this[t + --e], o = 1; e > 0 && (o *= 256);) n += this[t + --e] * o;\n        return n;\n      }, c.prototype.readUInt8 = function (t, e) {\n        return e || j(t, 1, this.length), this[t];\n      }, c.prototype.readUInt16LE = function (t, e) {\n        return e || j(t, 2, this.length), this[t] | this[t + 1] << 8;\n      }, c.prototype.readUInt16BE = function (t, e) {\n        return e || j(t, 2, this.length), this[t] << 8 | this[t + 1];\n      }, c.prototype.readUInt32LE = function (t, e) {\n        return e || j(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];\n      }, c.prototype.readUInt32BE = function (t, e) {\n        return e || j(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);\n      }, c.prototype.readIntLE = function (t, e, r) {\n        t |= 0, e |= 0, r || j(t, e, this.length);\n        for (var n = this[t], o = 1, i = 0; ++i < e && (o *= 256);) n += this[t + i] * o;\n        return n >= (o *= 128) && (n -= Math.pow(2, 8 * e)), n;\n      }, c.prototype.readIntBE = function (t, e, r) {\n        t |= 0, e |= 0, r || j(t, e, this.length);\n        for (var n = e, o = 1, i = this[t + --n]; n > 0 && (o *= 256);) i += this[t + --n] * o;\n        return i >= (o *= 128) && (i -= Math.pow(2, 8 * e)), i;\n      }, c.prototype.readInt8 = function (t, e) {\n        return e || j(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];\n      }, c.prototype.readInt16LE = function (t, e) {\n        e || j(t, 2, this.length);\n        var r = this[t] | this[t + 1] << 8;\n        return 32768 & r ? 4294901760 | r : r;\n      }, c.prototype.readInt16BE = function (t, e) {\n        e || j(t, 2, this.length);\n        var r = this[t + 1] | this[t] << 8;\n        return 32768 & r ? 4294901760 | r : r;\n      }, c.prototype.readInt32LE = function (t, e) {\n        return e || j(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;\n      }, c.prototype.readInt32BE = function (t, e) {\n        return e || j(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];\n      }, c.prototype.readFloatLE = function (t, e) {\n        return e || j(t, 4, this.length), o.read(this, t, !0, 23, 4);\n      }, c.prototype.readFloatBE = function (t, e) {\n        return e || j(t, 4, this.length), o.read(this, t, !1, 23, 4);\n      }, c.prototype.readDoubleLE = function (t, e) {\n        return e || j(t, 8, this.length), o.read(this, t, !0, 52, 8);\n      }, c.prototype.readDoubleBE = function (t, e) {\n        return e || j(t, 8, this.length), o.read(this, t, !1, 52, 8);\n      }, c.prototype.writeUIntLE = function (t, e, r, n) {\n        (t = +t, e |= 0, r |= 0, n) || C(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);\n        var o = 1,\n          i = 0;\n        for (this[e] = 255 & t; ++i < r && (o *= 256);) this[e + i] = t / o & 255;\n        return e + r;\n      }, c.prototype.writeUIntBE = function (t, e, r, n) {\n        (t = +t, e |= 0, r |= 0, n) || C(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);\n        var o = r - 1,\n          i = 1;\n        for (this[e + o] = 255 & t; --o >= 0 && (i *= 256);) this[e + o] = t / i & 255;\n        return e + r;\n      }, c.prototype.writeUInt8 = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 1, 255, 0), c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1;\n      }, c.prototype.writeUInt16LE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : B(this, t, e, !0), e + 2;\n      }, c.prototype.writeUInt16BE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : B(this, t, e, !1), e + 2;\n      }, c.prototype.writeUInt32LE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : L(this, t, e, !0), e + 4;\n      }, c.prototype.writeUInt32BE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : L(this, t, e, !1), e + 4;\n      }, c.prototype.writeIntLE = function (t, e, r, n) {\n        if (t = +t, e |= 0, !n) {\n          var o = Math.pow(2, 8 * r - 1);\n          C(this, t, e, r, o - 1, -o);\n        }\n        var i = 0,\n          s = 1,\n          a = 0;\n        for (this[e] = 255 & t; ++i < r && (s *= 256);) t < 0 && 0 === a && 0 !== this[e + i - 1] && (a = 1), this[e + i] = (t / s >> 0) - a & 255;\n        return e + r;\n      }, c.prototype.writeIntBE = function (t, e, r, n) {\n        if (t = +t, e |= 0, !n) {\n          var o = Math.pow(2, 8 * r - 1);\n          C(this, t, e, r, o - 1, -o);\n        }\n        var i = r - 1,\n          s = 1,\n          a = 0;\n        for (this[e + i] = 255 & t; --i >= 0 && (s *= 256);) t < 0 && 0 === a && 0 !== this[e + i + 1] && (a = 1), this[e + i] = (t / s >> 0) - a & 255;\n        return e + r;\n      }, c.prototype.writeInt8 = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 1, 127, -128), c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1;\n      }, c.prototype.writeInt16LE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : B(this, t, e, !0), e + 2;\n      }, c.prototype.writeInt16BE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : B(this, t, e, !1), e + 2;\n      }, c.prototype.writeInt32LE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 4, 2147483647, -2147483648), c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : L(this, t, e, !0), e + 4;\n      }, c.prototype.writeInt32BE = function (t, e, r) {\n        return t = +t, e |= 0, r || C(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : L(this, t, e, !1), e + 4;\n      }, c.prototype.writeFloatLE = function (t, e, r) {\n        return U(this, t, e, !0, r);\n      }, c.prototype.writeFloatBE = function (t, e, r) {\n        return U(this, t, e, !1, r);\n      }, c.prototype.writeDoubleLE = function (t, e, r) {\n        return D(this, t, e, !0, r);\n      }, c.prototype.writeDoubleBE = function (t, e, r) {\n        return D(this, t, e, !1, r);\n      }, c.prototype.copy = function (t, e, r, n) {\n        if (r || (r = 0), n || 0 === n || (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < r && (n = r), n === r) return 0;\n        if (0 === t.length || 0 === this.length) return 0;\n        if (e < 0) throw new RangeError(\"targetStart out of bounds\");\n        if (r < 0 || r >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n        if (n < 0) throw new RangeError(\"sourceEnd out of bounds\");\n        n > this.length && (n = this.length), t.length - e < n - r && (n = t.length - e + r);\n        var o,\n          i = n - r;\n        if (this === t && r < e && e < n) for (o = i - 1; o >= 0; --o) t[o + e] = this[o + r];else if (i < 1e3 || !c.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o) t[o + e] = this[o + r];else Uint8Array.prototype.set.call(t, this.subarray(r, r + i), e);\n        return i;\n      }, c.prototype.fill = function (t, e, r, n) {\n        if (\"string\" == typeof t) {\n          if (\"string\" == typeof e ? (n = e, e = 0, r = this.length) : \"string\" == typeof r && (n = r, r = this.length), 1 === t.length) {\n            var o = t.charCodeAt(0);\n            o < 256 && (t = o);\n          }\n          if (void 0 !== n && \"string\" != typeof n) throw new TypeError(\"encoding must be a string\");\n          if (\"string\" == typeof n && !c.isEncoding(n)) throw new TypeError(\"Unknown encoding: \" + n);\n        } else \"number\" == typeof t && (t &= 255);\n        if (e < 0 || this.length < e || this.length < r) throw new RangeError(\"Out of range index\");\n        if (r <= e) return this;\n        var i;\n        if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), \"number\" == typeof t) for (i = e; i < r; ++i) this[i] = t;else {\n          var s = c.isBuffer(t) ? t : F(new c(t, n).toString()),\n            a = s.length;\n          for (i = 0; i < r - e; ++i) this[i + e] = s[i % a];\n        }\n        return this;\n      };\n      var M = /[^+\\/0-9A-Za-z-_]/g;\n      function I(t) {\n        return t < 16 ? \"0\" + t.toString(16) : t.toString(16);\n      }\n      function F(t, e) {\n        var r;\n        e = e || 1 / 0;\n        for (var n = t.length, o = null, i = [], s = 0; s < n; ++s) {\n          if ((r = t.charCodeAt(s)) > 55295 && r < 57344) {\n            if (!o) {\n              if (r > 56319) {\n                (e -= 3) > -1 && i.push(239, 191, 189);\n                continue;\n              }\n              if (s + 1 === n) {\n                (e -= 3) > -1 && i.push(239, 191, 189);\n                continue;\n              }\n              o = r;\n              continue;\n            }\n            if (r < 56320) {\n              (e -= 3) > -1 && i.push(239, 191, 189), o = r;\n              continue;\n            }\n            r = 65536 + (o - 55296 << 10 | r - 56320);\n          } else o && (e -= 3) > -1 && i.push(239, 191, 189);\n          if (o = null, r < 128) {\n            if ((e -= 1) < 0) break;\n            i.push(r);\n          } else if (r < 2048) {\n            if ((e -= 2) < 0) break;\n            i.push(r >> 6 | 192, 63 & r | 128);\n          } else if (r < 65536) {\n            if ((e -= 3) < 0) break;\n            i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);\n          } else {\n            if (!(r < 1114112)) throw new Error(\"Invalid code point\");\n            if ((e -= 4) < 0) break;\n            i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);\n          }\n        }\n        return i;\n      }\n      function q(t) {\n        return n.toByteArray(function (t) {\n          if ((t = function (t) {\n            return t.trim ? t.trim() : t.replace(/^\\s+|\\s+$/g, \"\");\n          }(t).replace(M, \"\")).length < 2) return \"\";\n          for (; t.length % 4 != 0;) t += \"=\";\n          return t;\n        }(t));\n      }\n      function Y(t, e, r, n) {\n        for (var o = 0; o < n && !(o + r >= e.length || o >= t.length); ++o) e[o + r] = t[o];\n        return o;\n      }\n    }).call(this, r(14));\n  }, function (t, e) {\n    var r;\n    r = function () {\n      return this;\n    }();\n    try {\n      r = r || new Function(\"return this\")();\n    } catch (t) {\n      \"object\" == typeof window && (r = window);\n    }\n    t.exports = r;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var n = window.URL || window.webkitURL;\n    t.exports = function (t) {\n      try {\n        var e;\n        try {\n          (e = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder)()).append(t), e = e.getBlob(\"application/javascript; charset=utf-8\");\n        } catch (r) {\n          e = new Blob([t], {\n            type: \"application/javascript; charset=utf-8\"\n          });\n        }\n        return n.createObjectURL(e);\n      } catch (e) {\n        return \"data:application/javascript,\" + encodeURIComponent(t);\n      }\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    (function (t) {\n      r.d(e, \"a\", function () {\n        return h;\n      });\n      var n = r(8),\n        o = r(9),\n        i = r(11),\n        s = r(4),\n        a = r(5),\n        c = r(6);\n      const u = \"undefined\" != typeof navigator && \"string\" == typeof navigator.product && \"reactnative\" === navigator.product.toLowerCase();\n      class h extends n.a {\n        constructor(t) {\n          super(t), this.supportsBinary = !t.forceBase64;\n        }\n        get name() {\n          return \"websocket\";\n        }\n        doOpen() {\n          if (!this.check()) return;\n          const t = this.uri(),\n            e = this.opts.protocols,\n            r = u ? {} : Object(s.c)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n          this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);\n          try {\n            this.ws = a.d && !u ? e ? new a.a(t, e) : new a.a(t) : new a.a(t, e, r);\n          } catch (t) {\n            return this.emitReserved(\"error\", t);\n          }\n          this.ws.binaryType = this.socket.binaryType || a.b, this.addEventListeners();\n        }\n        addEventListeners() {\n          this.ws.onopen = () => {\n            this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n          }, this.ws.onclose = t => this.onClose({\n            description: \"websocket connection closed\",\n            context: t\n          }), this.ws.onmessage = t => this.onData(t.data), this.ws.onerror = t => this.onError(\"websocket error\", t);\n        }\n        write(e) {\n          this.writable = !1;\n          for (let r = 0; r < e.length; r++) {\n            const n = e[r],\n              o = r === e.length - 1;\n            Object(c.c)(n, this.supportsBinary, e => {\n              const r = {};\n              if (!a.d && (n.options && (r.compress = n.options.compress), this.opts.perMessageDeflate)) {\n                (\"string\" == typeof e ? t.byteLength(e) : e.length) < this.opts.perMessageDeflate.threshold && (r.compress = !1);\n              }\n              try {\n                a.d ? this.ws.send(e) : this.ws.send(e, r);\n              } catch (t) {}\n              o && Object(a.c)(() => {\n                this.writable = !0, this.emitReserved(\"drain\");\n              }, this.setTimeoutFn);\n            });\n          }\n        }\n        doClose() {\n          void 0 !== this.ws && (this.ws.close(), this.ws = null);\n        }\n        uri() {\n          let t = this.query || {};\n          const e = this.opts.secure ? \"wss\" : \"ws\";\n          let r = \"\";\n          this.opts.port && (\"wss\" === e && 443 !== Number(this.opts.port) || \"ws\" === e && 80 !== Number(this.opts.port)) && (r = \":\" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = Object(i.a)()), this.supportsBinary || (t.b64 = 1);\n          const n = Object(o.b)(t);\n          return e + \"://\" + (-1 !== this.opts.hostname.indexOf(\":\") ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (n.length ? \"?\" + n : \"\");\n        }\n        check() {\n          return !!a.a;\n        }\n      }\n    }).call(this, r(13).Buffer);\n  }, function (t, e, r) {\n    t.exports = r(15)('!function(t){var e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)r.d(n,o,function(e){return t[e]}.bind(null,o));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,\"a\",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p=\"\",r(r.s=0)}([function(t,e){class r extends AudioWorkletProcessor{constructor(t){super(t),Object.assign(this,t.processorOptions,{uint8:new Uint8Array(0)}),this.port.onmessage=this.appendBuffers.bind(this)}async appendBuffers({data:{buffer:t}}){const e=new Uint8Array(this.uint8.length+t.length);return e.set(this.uint8,0),e.set(t,this.uint8.length),this.uint8=e,!0}endOfStream(){this.port.postMessage({ended:!0,currentTime:currentTime,currentFrame:currentFrame})}process(t,e){const r=e[0];if(this.offset>=this.uint8.length)return!0;const n=new Uint8Array(256);for(let t=0;t<256&&!(this.offset>=this.uint8.length);t++,this.offset++)n[t]=this.uint8[this.offset];const o=new Uint16Array(n.buffer);for(let t=0;t<o.length;t++){const e=o[t],n=e>=32768?-(65536-e)/32768:e/32767;r[0][t]=n}return this.uint8.length-this.offset>25e3&&(this.offset+=1e4),!0}}registerProcessor(\"audio-data-worklet-stream\",r)}]);');\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var n = r(19),\n      o = r.n(n);\n    e.a = o.a;\n  }, function (t, e) {\n    t.exports = \"object\" == typeof self ? self.FormData : window.FormData;\n  }, function (t, e, r) {\n    t.exports = r(15)('!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=0)}([function(e,t){class r extends AudioWorkletProcessor{constructor(e){super(e),this.init(),this.src=null,this.accumulatedPCM=[],this.sampleRate=e.processorOptions.sampleRate}async init(){const{create:e,ConverterType:t}=globalThis.LibSampleRate;e(1,this.sampleRate||48e3,16e3,{converterType:t.SRC_SINC_BEST_QUALITY}).then(e=>{this.src=e})}process(e,t,r){for(let r=0;r<e.length;r++){let n=e[r];for(let e=0;e<n.length;e++){let o=n[e];for(let n=0;n<o.length;n++)t[r][e][n]=o[n]}}if(null!=this.src){const t=this.src.full(e[0][0]),r=this.convertToPCM(t);for(this.accumulatedPCM.push(...r);this.accumulatedPCM.length>=320;){const e=this.accumulatedPCM.splice(0,320);this.port.postMessage(new Int16Array(e).buffer)}}return!0}convertToPCM(e){const t=new Int16Array(e.length);for(let r=0;r<e.length;r++)t[r]=Math.max(-32768,Math.min(32767,Math.floor(32767*e[r])));return t}}registerProcessor(\"resample-processor\",r)}]);');\n  }, function (t, e, r) {\n    t.exports = r(25).default;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    e.byteLength = function (t) {\n      var e = u(t),\n        r = e[0],\n        n = e[1];\n      return 3 * (r + n) / 4 - n;\n    }, e.toByteArray = function (t) {\n      var e,\n        r,\n        n = u(t),\n        s = n[0],\n        a = n[1],\n        c = new i(function (t, e, r) {\n          return 3 * (e + r) / 4 - r;\n        }(0, s, a)),\n        h = 0,\n        f = a > 0 ? s - 4 : s;\n      for (r = 0; r < f; r += 4) e = o[t.charCodeAt(r)] << 18 | o[t.charCodeAt(r + 1)] << 12 | o[t.charCodeAt(r + 2)] << 6 | o[t.charCodeAt(r + 3)], c[h++] = e >> 16 & 255, c[h++] = e >> 8 & 255, c[h++] = 255 & e;\n      2 === a && (e = o[t.charCodeAt(r)] << 2 | o[t.charCodeAt(r + 1)] >> 4, c[h++] = 255 & e);\n      1 === a && (e = o[t.charCodeAt(r)] << 10 | o[t.charCodeAt(r + 1)] << 4 | o[t.charCodeAt(r + 2)] >> 2, c[h++] = e >> 8 & 255, c[h++] = 255 & e);\n      return c;\n    }, e.fromByteArray = function (t) {\n      for (var e, r = t.length, o = r % 3, i = [], s = 0, a = r - o; s < a; s += 16383) i.push(h(t, s, s + 16383 > a ? a : s + 16383));\n      1 === o ? (e = t[r - 1], i.push(n[e >> 2] + n[e << 4 & 63] + \"==\")) : 2 === o && (e = (t[r - 2] << 8) + t[r - 1], i.push(n[e >> 10] + n[e >> 4 & 63] + n[e << 2 & 63] + \"=\"));\n      return i.join(\"\");\n    };\n    for (var n = [], o = [], i = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", a = 0, c = s.length; a < c; ++a) n[a] = s[a], o[s.charCodeAt(a)] = a;\n    function u(t) {\n      var e = t.length;\n      if (e % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      var r = t.indexOf(\"=\");\n      return -1 === r && (r = e), [r, r === e ? 0 : 4 - r % 4];\n    }\n    function h(t, e, r) {\n      for (var o, i, s = [], a = e; a < r; a += 3) o = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), s.push(n[(i = o) >> 18 & 63] + n[i >> 12 & 63] + n[i >> 6 & 63] + n[63 & i]);\n      return s.join(\"\");\n    }\n    o[\"-\".charCodeAt(0)] = 62, o[\"_\".charCodeAt(0)] = 63;\n  }, function (t, e) {\n    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n    e.read = function (t, e, r, n, o) {\n      var i,\n        s,\n        a = 8 * o - n - 1,\n        c = (1 << a) - 1,\n        u = c >> 1,\n        h = -7,\n        f = r ? o - 1 : 0,\n        l = r ? -1 : 1,\n        p = t[e + f];\n      for (f += l, i = p & (1 << -h) - 1, p >>= -h, h += a; h > 0; i = 256 * i + t[e + f], f += l, h -= 8);\n      for (s = i & (1 << -h) - 1, i >>= -h, h += n; h > 0; s = 256 * s + t[e + f], f += l, h -= 8);\n      if (0 === i) i = 1 - u;else {\n        if (i === c) return s ? NaN : 1 / 0 * (p ? -1 : 1);\n        s += Math.pow(2, n), i -= u;\n      }\n      return (p ? -1 : 1) * s * Math.pow(2, i - n);\n    }, e.write = function (t, e, r, n, o, i) {\n      var s,\n        a,\n        c,\n        u = 8 * i - o - 1,\n        h = (1 << u) - 1,\n        f = h >> 1,\n        l = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n        p = n ? 0 : i - 1,\n        d = n ? 1 : -1,\n        y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (e += s + f >= 1 ? l / c : l * Math.pow(2, 1 - f)) * c >= 2 && (s++, c /= 2), s + f >= h ? (a = 0, s = h) : s + f >= 1 ? (a = (e * c - 1) * Math.pow(2, o), s += f) : (a = e * Math.pow(2, f - 1) * Math.pow(2, o), s = 0)); o >= 8; t[r + p] = 255 & a, p += d, a /= 256, o -= 8);\n      for (s = s << o | a, u += o; u > 0; t[r + p] = 255 & s, p += d, s /= 256, u -= 8);\n      t[r + p - d] |= 128 * y;\n    };\n  }, function (t, e) {\n    var r = {}.toString;\n    t.exports = Array.isArray || function (t) {\n      return \"[object Array]\" == r.call(t);\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.r(e);\n    var n = {};\n    r.r(n), r.d(n, \"protocol\", function () {\n      return C;\n    }), r.d(n, \"PacketType\", function () {\n      return B;\n    }), r.d(n, \"Encoder\", function () {\n      return L;\n    }), r.d(n, \"Decoder\", function () {\n      return N;\n    });\n    var o = r(8),\n      i = r(11),\n      s = r(9),\n      a = r(6);\n    let c = !1;\n    try {\n      c = \"undefined\" != typeof XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest();\n    } catch (t) {}\n    const u = c;\n    var h = r(2);\n    function f(t) {\n      const e = t.xdomain;\n      try {\n        if (\"undefined\" != typeof XMLHttpRequest && (!e || u)) return new XMLHttpRequest();\n      } catch (t) {}\n      if (!e) try {\n        return new h.a[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n      } catch (t) {}\n    }\n    var l = r(3),\n      p = r(4);\n    function d() {}\n    const y = null != new f({\n      xdomain: !1\n    }).responseType;\n    class m extends o.a {\n      constructor(t) {\n        if (super(t), this.polling = !1, \"undefined\" != typeof location) {\n          const e = \"https:\" === location.protocol;\n          let r = location.port;\n          r || (r = e ? \"443\" : \"80\"), this.xd = \"undefined\" != typeof location && t.hostname !== location.hostname || r !== t.port, this.xs = t.secure !== e;\n        }\n        const e = t && t.forceBase64;\n        this.supportsBinary = y && !e;\n      }\n      get name() {\n        return \"polling\";\n      }\n      doOpen() {\n        this.poll();\n      }\n      pause(t) {\n        this.readyState = \"pausing\";\n        const e = () => {\n          this.readyState = \"paused\", t();\n        };\n        if (this.polling || !this.writable) {\n          let t = 0;\n          this.polling && (t++, this.once(\"pollComplete\", function () {\n            --t || e();\n          })), this.writable || (t++, this.once(\"drain\", function () {\n            --t || e();\n          }));\n        } else e();\n      }\n      poll() {\n        this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n      }\n      onData(t) {\n        Object(a.b)(t, this.socket.binaryType).forEach(t => {\n          if (\"opening\" === this.readyState && \"open\" === t.type && this.onOpen(), \"close\" === t.type) return this.onClose({\n            description: \"transport closed by the server\"\n          }), !1;\n          this.onPacket(t);\n        }), \"closed\" !== this.readyState && (this.polling = !1, this.emitReserved(\"pollComplete\"), \"open\" === this.readyState && this.poll());\n      }\n      doClose() {\n        const t = () => {\n          this.write([{\n            type: \"close\"\n          }]);\n        };\n        \"open\" === this.readyState ? t() : this.once(\"open\", t);\n      }\n      write(t) {\n        this.writable = !1, Object(a.d)(t, t => {\n          this.doWrite(t, () => {\n            this.writable = !0, this.emitReserved(\"drain\");\n          });\n        });\n      }\n      uri() {\n        let t = this.query || {};\n        const e = this.opts.secure ? \"https\" : \"http\";\n        let r = \"\";\n        !1 !== this.opts.timestampRequests && (t[this.opts.timestampParam] = Object(i.a)()), this.supportsBinary || t.sid || (t.b64 = 1), this.opts.port && (\"https\" === e && 443 !== Number(this.opts.port) || \"http\" === e && 80 !== Number(this.opts.port)) && (r = \":\" + this.opts.port);\n        const n = Object(s.b)(t);\n        return e + \"://\" + (-1 !== this.opts.hostname.indexOf(\":\") ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (n.length ? \"?\" + n : \"\");\n      }\n      request() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return Object.assign(t, {\n          xd: this.xd,\n          xs: this.xs\n        }, this.opts), new g(this.uri(), t);\n      }\n      doWrite(t, e) {\n        const r = this.request({\n          method: \"POST\",\n          data: t\n        });\n        r.on(\"success\", e), r.on(\"error\", (t, e) => {\n          this.onError(\"xhr post error\", t, e);\n        });\n      }\n      doPoll() {\n        const t = this.request();\n        t.on(\"data\", this.onData.bind(this)), t.on(\"error\", (t, e) => {\n          this.onError(\"xhr poll error\", t, e);\n        }), this.pollXhr = t;\n      }\n    }\n    class g extends l.a {\n      constructor(t, e) {\n        super(), Object(p.b)(this, e), this.opts = e, this.method = e.method || \"GET\", this.uri = t, this.async = !1 !== e.async, this.data = void 0 !== e.data ? e.data : null, this.create();\n      }\n      create() {\n        const t = Object(p.c)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;\n        const e = this.xhr = new f(t);\n        try {\n          e.open(this.method, this.uri, this.async);\n          try {\n            if (this.opts.extraHeaders) {\n              e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);\n              for (let t in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(t) && e.setRequestHeader(t, this.opts.extraHeaders[t]);\n            }\n          } catch (t) {}\n          if (\"POST\" === this.method) try {\n            e.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n          } catch (t) {}\n          try {\n            e.setRequestHeader(\"Accept\", \"*/*\");\n          } catch (t) {}\n          \"withCredentials\" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {\n            4 === e.readyState && (200 === e.status || 1223 === e.status ? this.onLoad() : this.setTimeoutFn(() => {\n              this.onError(\"number\" == typeof e.status ? e.status : 0);\n            }, 0));\n          }, e.send(this.data);\n        } catch (t) {\n          return void this.setTimeoutFn(() => {\n            this.onError(t);\n          }, 0);\n        }\n        \"undefined\" != typeof document && (this.index = g.requestsCount++, g.requests[this.index] = this);\n      }\n      onError(t) {\n        this.emitReserved(\"error\", t, this.xhr), this.cleanup(!0);\n      }\n      cleanup(t) {\n        if (void 0 !== this.xhr && null !== this.xhr) {\n          if (this.xhr.onreadystatechange = d, t) try {\n            this.xhr.abort();\n          } catch (t) {}\n          \"undefined\" != typeof document && delete g.requests[this.index], this.xhr = null;\n        }\n      }\n      onLoad() {\n        const t = this.xhr.responseText;\n        null !== t && (this.emitReserved(\"data\", t), this.emitReserved(\"success\"), this.cleanup());\n      }\n      abort() {\n        this.cleanup();\n      }\n    }\n    if (g.requestsCount = 0, g.requests = {}, \"undefined\" != typeof document) if (\"function\" == typeof attachEvent) attachEvent(\"onunload\", v);else if (\"function\" == typeof addEventListener) {\n      const t = \"onpagehide\" in h.a ? \"pagehide\" : \"unload\";\n      addEventListener(t, v, !1);\n    }\n    function v() {\n      for (let t in g.requests) g.requests.hasOwnProperty(t) && g.requests[t].abort();\n    }\n    const b = {\n        websocket: r(16).a,\n        polling: m\n      },\n      w = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      E = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n    function _(t) {\n      const e = t,\n        r = t.indexOf(\"[\"),\n        n = t.indexOf(\"]\");\n      -1 != r && -1 != n && (t = t.substring(0, r) + t.substring(r, n).replace(/:/g, \";\") + t.substring(n, t.length));\n      let o = w.exec(t || \"\"),\n        i = {},\n        s = 14;\n      for (; s--;) i[E[s]] = o[s] || \"\";\n      return -1 != r && -1 != n && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, \":\"), i.authority = i.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), i.ipv6uri = !0), i.pathNames = function (t, e) {\n        const r = e.replace(/\\/{2,9}/g, \"/\").split(\"/\");\n        \"/\" != e.slice(0, 1) && 0 !== e.length || r.splice(0, 1);\n        \"/\" == e.slice(-1) && r.splice(r.length - 1, 1);\n        return r;\n      }(0, i.path), i.queryKey = function (t, e) {\n        const r = {};\n        return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (t, e, n) {\n          e && (r[e] = n);\n        }), r;\n      }(0, i.query), i;\n    }\n    class O extends l.a {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(), this.writeBuffer = [], t && \"object\" == typeof t && (e = t, t = null), t ? (t = _(t), e.hostname = t.host, e.secure = \"https\" === t.protocol || \"wss\" === t.protocol, e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = _(e.host).host), Object(p.b)(this, e), this.secure = null != e.secure ? e.secure : \"undefined\" != typeof location && \"https:\" === location.protocol, e.hostname && !e.port && (e.port = this.secure ? \"443\" : \"80\"), this.hostname = e.hostname || (\"undefined\" != typeof location ? location.hostname : \"localhost\"), this.port = e.port || (\"undefined\" != typeof location && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = e.transports || [\"polling\", \"websocket\"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n          path: \"/engine.io\",\n          agent: !1,\n          withCredentials: !1,\n          upgrade: !0,\n          timestampParam: \"t\",\n          rememberUpgrade: !1,\n          addTrailingSlash: !0,\n          rejectUnauthorized: !0,\n          perMessageDeflate: {\n            threshold: 1024\n          },\n          transportOptions: {},\n          closeOnBeforeunload: !0\n        }, e), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\"), \"string\" == typeof this.opts.query && (this.opts.query = Object(s.a)(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, \"function\" == typeof addEventListener && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {\n          this.transport && (this.transport.removeAllListeners(), this.transport.close());\n        }, addEventListener(\"beforeunload\", this.beforeunloadEventListener, !1)), \"localhost\" !== this.hostname && (this.offlineEventListener = () => {\n          this.onClose(\"transport close\", {\n            description: \"network connection lost\"\n          });\n        }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n      }\n      createTransport(t) {\n        const e = Object.assign({}, this.opts.query);\n        e.EIO = a.e, e.transport = t, this.id && (e.sid = this.id);\n        const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {\n          query: e,\n          socket: this,\n          hostname: this.hostname,\n          secure: this.secure,\n          port: this.port\n        });\n        return new b[t](r);\n      }\n      open() {\n        let t;\n        if (this.opts.rememberUpgrade && O.priorWebsocketSuccess && -1 !== this.transports.indexOf(\"websocket\")) t = \"websocket\";else {\n          if (0 === this.transports.length) return void this.setTimeoutFn(() => {\n            this.emitReserved(\"error\", \"No transports available\");\n          }, 0);\n          t = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        try {\n          t = this.createTransport(t);\n        } catch (t) {\n          return this.transports.shift(), void this.open();\n        }\n        t.open(), this.setTransport(t);\n      }\n      setTransport(t) {\n        this.transport && this.transport.removeAllListeners(), this.transport = t, t.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", t => this.onClose(\"transport close\", t));\n      }\n      probe(t) {\n        let e = this.createTransport(t),\n          r = !1;\n        O.priorWebsocketSuccess = !1;\n        const n = () => {\n          r || (e.send([{\n            type: \"ping\",\n            data: \"probe\"\n          }]), e.once(\"packet\", t => {\n            if (!r) if (\"pong\" === t.type && \"probe\" === t.data) {\n              if (this.upgrading = !0, this.emitReserved(\"upgrading\", e), !e) return;\n              O.priorWebsocketSuccess = \"websocket\" === e.name, this.transport.pause(() => {\n                r || \"closed\" !== this.readyState && (u(), this.setTransport(e), e.send([{\n                  type: \"upgrade\"\n                }]), this.emitReserved(\"upgrade\", e), e = null, this.upgrading = !1, this.flush());\n              });\n            } else {\n              const t = new Error(\"probe error\");\n              t.transport = e.name, this.emitReserved(\"upgradeError\", t);\n            }\n          }));\n        };\n        function o() {\n          r || (r = !0, u(), e.close(), e = null);\n        }\n        const i = t => {\n          const r = new Error(\"probe error: \" + t);\n          r.transport = e.name, o(), this.emitReserved(\"upgradeError\", r);\n        };\n        function s() {\n          i(\"transport closed\");\n        }\n        function a() {\n          i(\"socket closed\");\n        }\n        function c(t) {\n          e && t.name !== e.name && o();\n        }\n        const u = () => {\n          e.removeListener(\"open\", n), e.removeListener(\"error\", i), e.removeListener(\"close\", s), this.off(\"close\", a), this.off(\"upgrading\", c);\n        };\n        e.once(\"open\", n), e.once(\"error\", i), e.once(\"close\", s), this.once(\"close\", a), this.once(\"upgrading\", c), e.open();\n      }\n      onOpen() {\n        if (this.readyState = \"open\", O.priorWebsocketSuccess = \"websocket\" === this.transport.name, this.emitReserved(\"open\"), this.flush(), \"open\" === this.readyState && this.opts.upgrade) {\n          let t = 0;\n          const e = this.upgrades.length;\n          for (; t < e; t++) this.probe(this.upgrades[t]);\n        }\n      }\n      onPacket(t) {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) switch (this.emitReserved(\"packet\", t), this.emitReserved(\"heartbeat\"), t.type) {\n          case \"open\":\n            this.onHandshake(JSON.parse(t.data));\n            break;\n          case \"ping\":\n            this.resetPingTimeout(), this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n            break;\n          case \"error\":\n            const e = new Error(\"server error\");\n            e.code = t.data, this.onError(e);\n            break;\n          case \"message\":\n            this.emitReserved(\"data\", t.data), this.emitReserved(\"message\", t.data);\n        }\n      }\n      onHandshake(t) {\n        this.emitReserved(\"handshake\", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), \"closed\" !== this.readyState && this.resetPingTimeout();\n      }\n      resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n          this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n      }\n      onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved(\"drain\") : this.flush();\n      }\n      flush() {\n        if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n          const t = this.getWritablePackets();\n          this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved(\"flush\");\n        }\n      }\n      getWritablePackets() {\n        if (!(this.maxPayload && \"polling\" === this.transport.name && this.writeBuffer.length > 1)) return this.writeBuffer;\n        let t = 1;\n        for (let e = 0; e < this.writeBuffer.length; e++) {\n          const r = this.writeBuffer[e].data;\n          if (r && (t += Object(p.a)(r)), e > 0 && t > this.maxPayload) return this.writeBuffer.slice(0, e);\n          t += 2;\n        }\n        return this.writeBuffer;\n      }\n      write(t, e, r) {\n        return this.sendPacket(\"message\", t, e, r), this;\n      }\n      send(t, e, r) {\n        return this.sendPacket(\"message\", t, e, r), this;\n      }\n      sendPacket(t, e, r, n) {\n        if (\"function\" == typeof e && (n = e, e = void 0), \"function\" == typeof r && (n = r, r = null), \"closing\" === this.readyState || \"closed\" === this.readyState) return;\n        (r = r || {}).compress = !1 !== r.compress;\n        const o = {\n          type: t,\n          data: e,\n          options: r\n        };\n        this.emitReserved(\"packetCreate\", o), this.writeBuffer.push(o), n && this.once(\"flush\", n), this.flush();\n      }\n      close() {\n        const t = () => {\n            this.onClose(\"forced close\"), this.transport.close();\n          },\n          e = () => {\n            this.off(\"upgrade\", e), this.off(\"upgradeError\", e), t();\n          },\n          r = () => {\n            this.once(\"upgrade\", e), this.once(\"upgradeError\", e);\n          };\n        return \"opening\" !== this.readyState && \"open\" !== this.readyState || (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n          this.upgrading ? r() : t();\n        }) : this.upgrading ? r() : t()), this;\n      }\n      onError(t) {\n        O.priorWebsocketSuccess = !1, this.emitReserved(\"error\", t), this.onClose(\"transport error\", t);\n      }\n      onClose(t, e) {\n        \"opening\" !== this.readyState && \"open\" !== this.readyState && \"closing\" !== this.readyState || (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), \"function\" == typeof removeEventListener && (removeEventListener(\"beforeunload\", this.beforeunloadEventListener, !1), removeEventListener(\"offline\", this.offlineEventListener, !1)), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", t, e), this.writeBuffer = [], this.prevBufferLen = 0);\n      }\n      filterUpgrades(t) {\n        const e = [];\n        let r = 0;\n        const n = t.length;\n        for (; r < n; r++) ~this.transports.indexOf(t[r]) && e.push(t[r]);\n        return e;\n      }\n    }\n    O.protocol = a.e;\n    var S = r(5);\n    O.protocol;\n    const k = \"function\" == typeof ArrayBuffer,\n      A = Object.prototype.toString,\n      R = \"function\" == typeof Blob || \"undefined\" != typeof Blob && \"[object BlobConstructor]\" === A.call(Blob),\n      x = \"function\" == typeof File || \"undefined\" != typeof File && \"[object FileConstructor]\" === A.call(File);\n    function T(t) {\n      return k && (t instanceof ArrayBuffer || (t => \"function\" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer)(t)) || R && t instanceof Blob || x && t instanceof File;\n    }\n    function P(t) {\n      const e = [],\n        r = t.data,\n        n = t;\n      return n.data = function t(e, r) {\n        if (!e) return e;\n        if (T(e)) {\n          const t = {\n            _placeholder: !0,\n            num: r.length\n          };\n          return r.push(e), t;\n        }\n        if (Array.isArray(e)) {\n          const n = new Array(e.length);\n          for (let o = 0; o < e.length; o++) n[o] = t(e[o], r);\n          return n;\n        }\n        if (\"object\" == typeof e && !(e instanceof Date)) {\n          const n = {};\n          for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && (n[o] = t(e[o], r));\n          return n;\n        }\n        return e;\n      }(r, e), n.attachments = e.length, {\n        packet: n,\n        buffers: e\n      };\n    }\n    function j(t, e) {\n      return t.data = function t(e, r) {\n        if (!e) return e;\n        if (e && !0 === e._placeholder) {\n          if (\"number\" == typeof e.num && e.num >= 0 && e.num < r.length) return r[e.num];\n          throw new Error(\"illegal attachments\");\n        }\n        if (Array.isArray(e)) for (let n = 0; n < e.length; n++) e[n] = t(e[n], r);else if (\"object\" == typeof e) for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (e[n] = t(e[n], r));\n        return e;\n      }(t.data, e), t.attachments = void 0, t;\n    }\n    const C = 5;\n    var B;\n    !function (t) {\n      t[t.CONNECT = 0] = \"CONNECT\", t[t.DISCONNECT = 1] = \"DISCONNECT\", t[t.EVENT = 2] = \"EVENT\", t[t.ACK = 3] = \"ACK\", t[t.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", t[t.BINARY_EVENT = 5] = \"BINARY_EVENT\", t[t.BINARY_ACK = 6] = \"BINARY_ACK\";\n    }(B || (B = {}));\n    class L {\n      constructor(t) {\n        this.replacer = t;\n      }\n      encode(t) {\n        return t.type !== B.EVENT && t.type !== B.ACK || !function t(e, r) {\n          if (!e || \"object\" != typeof e) return !1;\n          if (Array.isArray(e)) {\n            for (let r = 0, n = e.length; r < n; r++) if (t(e[r])) return !0;\n            return !1;\n          }\n          if (T(e)) return !0;\n          if (e.toJSON && \"function\" == typeof e.toJSON && 1 === arguments.length) return t(e.toJSON(), !0);\n          for (const r in e) if (Object.prototype.hasOwnProperty.call(e, r) && t(e[r])) return !0;\n          return !1;\n        }(t) ? [this.encodeAsString(t)] : (t.type = t.type === B.EVENT ? B.BINARY_EVENT : B.BINARY_ACK, this.encodeAsBinary(t));\n      }\n      encodeAsString(t) {\n        let e = \"\" + t.type;\n        return t.type !== B.BINARY_EVENT && t.type !== B.BINARY_ACK || (e += t.attachments + \"-\"), t.nsp && \"/\" !== t.nsp && (e += t.nsp + \",\"), null != t.id && (e += t.id), null != t.data && (e += JSON.stringify(t.data, this.replacer)), e;\n      }\n      encodeAsBinary(t) {\n        const e = P(t),\n          r = this.encodeAsString(e.packet),\n          n = e.buffers;\n        return n.unshift(r), n;\n      }\n    }\n    class N extends l.a {\n      constructor(t) {\n        super(), this.reviver = t;\n      }\n      add(t) {\n        let e;\n        if (\"string\" == typeof t) {\n          if (this.reconstructor) throw new Error(\"got plaintext data when reconstructing a packet\");\n          e = this.decodeString(t), e.type === B.BINARY_EVENT || e.type === B.BINARY_ACK ? (this.reconstructor = new U(e), 0 === e.attachments && super.emitReserved(\"decoded\", e)) : super.emitReserved(\"decoded\", e);\n        } else {\n          if (!T(t) && !t.base64) throw new Error(\"Unknown type: \" + t);\n          if (!this.reconstructor) throw new Error(\"got binary data when not reconstructing a packet\");\n          e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved(\"decoded\", e));\n        }\n      }\n      decodeString(t) {\n        let e = 0;\n        const r = {\n          type: Number(t.charAt(0))\n        };\n        if (void 0 === B[r.type]) throw new Error(\"unknown packet type \" + r.type);\n        if (r.type === B.BINARY_EVENT || r.type === B.BINARY_ACK) {\n          const n = e + 1;\n          for (; \"-\" !== t.charAt(++e) && e != t.length;);\n          const o = t.substring(n, e);\n          if (o != Number(o) || \"-\" !== t.charAt(e)) throw new Error(\"Illegal attachments\");\n          r.attachments = Number(o);\n        }\n        if (\"/\" === t.charAt(e + 1)) {\n          const n = e + 1;\n          for (; ++e;) {\n            if (\",\" === t.charAt(e)) break;\n            if (e === t.length) break;\n          }\n          r.nsp = t.substring(n, e);\n        } else r.nsp = \"/\";\n        const n = t.charAt(e + 1);\n        if (\"\" !== n && Number(n) == n) {\n          const n = e + 1;\n          for (; ++e;) {\n            const r = t.charAt(e);\n            if (null == r || Number(r) != r) {\n              --e;\n              break;\n            }\n            if (e === t.length) break;\n          }\n          r.id = Number(t.substring(n, e + 1));\n        }\n        if (t.charAt(++e)) {\n          const n = this.tryParse(t.substr(e));\n          if (!N.isPayloadValid(r.type, n)) throw new Error(\"invalid payload\");\n          r.data = n;\n        }\n        return r;\n      }\n      tryParse(t) {\n        try {\n          return JSON.parse(t, this.reviver);\n        } catch (t) {\n          return !1;\n        }\n      }\n      static isPayloadValid(t, e) {\n        switch (t) {\n          case B.CONNECT:\n            return \"object\" == typeof e;\n          case B.DISCONNECT:\n            return void 0 === e;\n          case B.CONNECT_ERROR:\n            return \"string\" == typeof e || \"object\" == typeof e;\n          case B.EVENT:\n          case B.BINARY_EVENT:\n            return Array.isArray(e) && e.length > 0;\n          case B.ACK:\n          case B.BINARY_ACK:\n            return Array.isArray(e);\n        }\n      }\n      destroy() {\n        this.reconstructor && this.reconstructor.finishedReconstruction();\n      }\n    }\n    class U {\n      constructor(t) {\n        this.packet = t, this.buffers = [], this.reconPack = t;\n      }\n      takeBinaryData(t) {\n        if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {\n          const t = j(this.reconPack, this.buffers);\n          return this.finishedReconstruction(), t;\n        }\n        return null;\n      }\n      finishedReconstruction() {\n        this.reconPack = null, this.buffers = [];\n      }\n    }\n    function D(t, e, r) {\n      return t.on(e, r), function () {\n        t.off(e, r);\n      };\n    }\n    const M = Object.freeze({\n      connect: 1,\n      connect_error: 1,\n      disconnect: 1,\n      disconnecting: 1,\n      newListener: 1,\n      removeListener: 1\n    });\n    class I extends l.a {\n      constructor(t, e, r) {\n        super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();\n      }\n      get disconnected() {\n        return !this.connected;\n      }\n      subEvents() {\n        if (this.subs) return;\n        const t = this.io;\n        this.subs = [D(t, \"open\", this.onopen.bind(this)), D(t, \"packet\", this.onpacket.bind(this)), D(t, \"error\", this.onerror.bind(this)), D(t, \"close\", this.onclose.bind(this))];\n      }\n      get active() {\n        return !!this.subs;\n      }\n      connect() {\n        return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), \"open\" === this.io._readyState && this.onopen()), this;\n      }\n      open() {\n        return this.connect();\n      }\n      send() {\n        for (var _len2 = arguments.length, t = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          t[_key2] = arguments[_key2];\n        }\n        return t.unshift(\"message\"), this.emit.apply(this, t), this;\n      }\n      emit(t) {\n        if (M.hasOwnProperty(t)) throw new Error('\"' + t.toString() + '\" is a reserved event name');\n        for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          e[_key3 - 1] = arguments[_key3];\n        }\n        if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(e), this;\n        const r = {\n          type: B.EVENT,\n          data: e,\n          options: {}\n        };\n        if (r.options.compress = !1 !== this.flags.compress, \"function\" == typeof e[e.length - 1]) {\n          const t = this.ids++,\n            n = e.pop();\n          this._registerAckCallback(t, n), r.id = t;\n        }\n        const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n        return this.flags.volatile && (!n || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;\n      }\n      _registerAckCallback(t, e) {\n        var _this = this;\n        var r;\n        const n = null !== (r = this.flags.timeout) && void 0 !== r ? r : this._opts.ackTimeout;\n        if (void 0 === n) return void (this.acks[t] = e);\n        const o = this.io.setTimeoutFn(() => {\n          delete this.acks[t];\n          for (let e = 0; e < this.sendBuffer.length; e++) this.sendBuffer[e].id === t && this.sendBuffer.splice(e, 1);\n          e.call(this, new Error(\"operation has timed out\"));\n        }, n);\n        this.acks[t] = function () {\n          for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            t[_key4] = arguments[_key4];\n          }\n          _this.io.clearTimeoutFn(o), e.apply(_this, [null, ...t]);\n        };\n      }\n      emitWithAck(t) {\n        for (var _len5 = arguments.length, e = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n          e[_key5 - 1] = arguments[_key5];\n        }\n        const r = void 0 !== this.flags.timeout || void 0 !== this._opts.ackTimeout;\n        return new Promise((n, o) => {\n          e.push((t, e) => r ? t ? o(t) : n(e) : n(t)), this.emit(t, ...e);\n        });\n      }\n      _addToQueue(t) {\n        var _this2 = this;\n        let e;\n        \"function\" == typeof t[t.length - 1] && (e = t.pop());\n        const r = {\n          id: this.ids++,\n          tryCount: 0,\n          pending: !1,\n          args: t,\n          flags: Object.assign({\n            fromQueue: !0\n          }, this.flags)\n        };\n        t.push(function (t) {\n          if (r !== _this2._queue[0]) return;\n          for (var _len6 = arguments.length, n = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n            n[_key6 - 1] = arguments[_key6];\n          }\n          return null !== t ? r.tryCount > _this2._opts.retries && (_this2._queue.shift(), e && e(t)) : (_this2._queue.shift(), e && e(null, ...n)), r.pending = !1, _this2._drainQueue();\n        }), this._queue.push(r), this._drainQueue();\n      }\n      _drainQueue() {\n        if (0 === this._queue.length) return;\n        const t = this._queue[0];\n        if (t.pending) return;\n        t.pending = !0, t.tryCount++;\n        const e = this.ids;\n        this.ids = t.id, this.flags = t.flags, this.emit.apply(this, t.args), this.ids = e;\n      }\n      packet(t) {\n        t.nsp = this.nsp, this.io._packet(t);\n      }\n      onopen() {\n        \"function\" == typeof this.auth ? this.auth(t => {\n          this._sendConnectPacket(t);\n        }) : this._sendConnectPacket(this.auth);\n      }\n      _sendConnectPacket(t) {\n        this.packet({\n          type: B.CONNECT,\n          data: this._pid ? Object.assign({\n            pid: this._pid,\n            offset: this._lastOffset\n          }, t) : t\n        });\n      }\n      onerror(t) {\n        this.connected || this.emitReserved(\"connect_error\", t);\n      }\n      onclose(t, e) {\n        this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", t, e);\n      }\n      onpacket(t) {\n        if (t.nsp === this.nsp) switch (t.type) {\n          case B.CONNECT:\n            t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n            break;\n          case B.EVENT:\n          case B.BINARY_EVENT:\n            this.onevent(t);\n            break;\n          case B.ACK:\n          case B.BINARY_ACK:\n            this.onack(t);\n            break;\n          case B.DISCONNECT:\n            this.ondisconnect();\n            break;\n          case B.CONNECT_ERROR:\n            this.destroy();\n            const e = new Error(t.data.message);\n            e.data = t.data.data, this.emitReserved(\"connect_error\", e);\n        }\n      }\n      onevent(t) {\n        const e = t.data || [];\n        null != t.id && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));\n      }\n      emitEvent(t) {\n        if (this._anyListeners && this._anyListeners.length) {\n          const e = this._anyListeners.slice();\n          for (const r of e) r.apply(this, t);\n        }\n        super.emit.apply(this, t), this._pid && t.length && \"string\" == typeof t[t.length - 1] && (this._lastOffset = t[t.length - 1]);\n      }\n      ack(t) {\n        const e = this;\n        let r = !1;\n        return function () {\n          for (var _len7 = arguments.length, n = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n            n[_key7] = arguments[_key7];\n          }\n          r || (r = !0, e.packet({\n            type: B.ACK,\n            id: t,\n            data: n\n          }));\n        };\n      }\n      onack(t) {\n        const e = this.acks[t.id];\n        \"function\" == typeof e && (e.apply(this, t.data), delete this.acks[t.id]);\n      }\n      onconnect(t, e) {\n        this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\");\n      }\n      emitBuffered() {\n        this.receiveBuffer.forEach(t => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach(t => {\n          this.notifyOutgoingListeners(t), this.packet(t);\n        }), this.sendBuffer = [];\n      }\n      ondisconnect() {\n        this.destroy(), this.onclose(\"io server disconnect\");\n      }\n      destroy() {\n        this.subs && (this.subs.forEach(t => t()), this.subs = void 0), this.io._destroy(this);\n      }\n      disconnect() {\n        return this.connected && this.packet({\n          type: B.DISCONNECT\n        }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n      }\n      close() {\n        return this.disconnect();\n      }\n      compress(t) {\n        return this.flags.compress = t, this;\n      }\n      get volatile() {\n        return this.flags.volatile = !0, this;\n      }\n      timeout(t) {\n        return this.flags.timeout = t, this;\n      }\n      onAny(t) {\n        return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;\n      }\n      prependAny(t) {\n        return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;\n      }\n      offAny(t) {\n        if (!this._anyListeners) return this;\n        if (t) {\n          const e = this._anyListeners;\n          for (let r = 0; r < e.length; r++) if (t === e[r]) return e.splice(r, 1), this;\n        } else this._anyListeners = [];\n        return this;\n      }\n      listenersAny() {\n        return this._anyListeners || [];\n      }\n      onAnyOutgoing(t) {\n        return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;\n      }\n      prependAnyOutgoing(t) {\n        return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;\n      }\n      offAnyOutgoing(t) {\n        if (!this._anyOutgoingListeners) return this;\n        if (t) {\n          const e = this._anyOutgoingListeners;\n          for (let r = 0; r < e.length; r++) if (t === e[r]) return e.splice(r, 1), this;\n        } else this._anyOutgoingListeners = [];\n        return this;\n      }\n      listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n      }\n      notifyOutgoingListeners(t) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n          const e = this._anyOutgoingListeners.slice();\n          for (const r of e) r.apply(this, t.data);\n        }\n      }\n    }\n    function F(t) {\n      t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0;\n    }\n    F.prototype.duration = function () {\n      var t = this.ms * Math.pow(this.factor, this.attempts++);\n      if (this.jitter) {\n        var e = Math.random(),\n          r = Math.floor(e * this.jitter * t);\n        t = 0 == (1 & Math.floor(10 * e)) ? t - r : t + r;\n      }\n      return 0 | Math.min(t, this.max);\n    }, F.prototype.reset = function () {\n      this.attempts = 0;\n    }, F.prototype.setMin = function (t) {\n      this.ms = t;\n    }, F.prototype.setMax = function (t) {\n      this.max = t;\n    }, F.prototype.setJitter = function (t) {\n      this.jitter = t;\n    };\n    class q extends l.a {\n      constructor(t, e) {\n        var r;\n        super(), this.nsps = {}, this.subs = [], t && \"object\" == typeof t && (e = t, t = void 0), (e = e || {}).path = e.path || \"/socket.io\", this.opts = e, Object(p.b)(this, e), this.reconnection(!1 !== e.reconnection), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(null !== (r = e.randomizationFactor) && void 0 !== r ? r : .5), this.backoff = new F({\n          min: this.reconnectionDelay(),\n          max: this.reconnectionDelayMax(),\n          jitter: this.randomizationFactor()\n        }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this._readyState = \"closed\", this.uri = t;\n        const o = e.parser || n;\n        this.encoder = new o.Encoder(), this.decoder = new o.Decoder(), this._autoConnect = !1 !== e.autoConnect, this._autoConnect && this.open();\n      }\n      reconnection(t) {\n        return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;\n      }\n      reconnectionAttempts(t) {\n        return void 0 === t ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);\n      }\n      reconnectionDelay(t) {\n        var e;\n        return void 0 === t ? this._reconnectionDelay : (this._reconnectionDelay = t, null === (e = this.backoff) || void 0 === e || e.setMin(t), this);\n      }\n      randomizationFactor(t) {\n        var e;\n        return void 0 === t ? this._randomizationFactor : (this._randomizationFactor = t, null === (e = this.backoff) || void 0 === e || e.setJitter(t), this);\n      }\n      reconnectionDelayMax(t) {\n        var e;\n        return void 0 === t ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, null === (e = this.backoff) || void 0 === e || e.setMax(t), this);\n      }\n      timeout(t) {\n        return arguments.length ? (this._timeout = t, this) : this._timeout;\n      }\n      maybeReconnectOnOpen() {\n        !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();\n      }\n      open(t) {\n        if (~this._readyState.indexOf(\"open\")) return this;\n        this.engine = new O(this.uri, this.opts);\n        const e = this.engine,\n          r = this;\n        this._readyState = \"opening\", this.skipReconnect = !1;\n        const n = D(e, \"open\", function () {\n            r.onopen(), t && t();\n          }),\n          o = D(e, \"error\", e => {\n            r.cleanup(), r._readyState = \"closed\", this.emitReserved(\"error\", e), t ? t(e) : r.maybeReconnectOnOpen();\n          });\n        if (!1 !== this._timeout) {\n          const t = this._timeout;\n          0 === t && n();\n          const r = this.setTimeoutFn(() => {\n            n(), e.close(), e.emit(\"error\", new Error(\"timeout\"));\n          }, t);\n          this.opts.autoUnref && r.unref(), this.subs.push(function () {\n            clearTimeout(r);\n          });\n        }\n        return this.subs.push(n), this.subs.push(o), this;\n      }\n      connect(t) {\n        return this.open(t);\n      }\n      onopen() {\n        this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n        const t = this.engine;\n        this.subs.push(D(t, \"ping\", this.onping.bind(this)), D(t, \"data\", this.ondata.bind(this)), D(t, \"error\", this.onerror.bind(this)), D(t, \"close\", this.onclose.bind(this)), D(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n      }\n      onping() {\n        this.emitReserved(\"ping\");\n      }\n      ondata(t) {\n        try {\n          this.decoder.add(t);\n        } catch (t) {\n          this.onclose(\"parse error\", t);\n        }\n      }\n      ondecoded(t) {\n        Object(S.c)(() => {\n          this.emitReserved(\"packet\", t);\n        }, this.setTimeoutFn);\n      }\n      onerror(t) {\n        this.emitReserved(\"error\", t);\n      }\n      socket(t, e) {\n        let r = this.nsps[t];\n        return r || (r = new I(this, t, e), this.nsps[t] = r), this._autoConnect && r.connect(), r;\n      }\n      _destroy(t) {\n        const e = Object.keys(this.nsps);\n        for (const t of e) {\n          if (this.nsps[t].active) return;\n        }\n        this._close();\n      }\n      _packet(t) {\n        const e = this.encoder.encode(t);\n        for (let r = 0; r < e.length; r++) this.engine.write(e[r], t.options);\n      }\n      cleanup() {\n        this.subs.forEach(t => t()), this.subs.length = 0, this.decoder.destroy();\n      }\n      _close() {\n        this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n      }\n      disconnect() {\n        return this._close();\n      }\n      onclose(t, e) {\n        this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", t, e), this._reconnection && !this.skipReconnect && this.reconnect();\n      }\n      reconnect() {\n        if (this._reconnecting || this.skipReconnect) return this;\n        const t = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;else {\n          const e = this.backoff.duration();\n          this._reconnecting = !0;\n          const r = this.setTimeoutFn(() => {\n            t.skipReconnect || (this.emitReserved(\"reconnect_attempt\", t.backoff.attempts), t.skipReconnect || t.open(e => {\n              e ? (t._reconnecting = !1, t.reconnect(), this.emitReserved(\"reconnect_error\", e)) : t.onreconnect();\n            }));\n          }, e);\n          this.opts.autoUnref && r.unref(), this.subs.push(function () {\n            clearTimeout(r);\n          });\n        }\n      }\n      onreconnect() {\n        const t = this.backoff.attempts;\n        this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", t);\n      }\n    }\n    const Y = {};\n    function z(t, e) {\n      \"object\" == typeof t && (e = t, t = void 0);\n      const r = function (t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n          let r = arguments.length > 2 ? arguments[2] : undefined;\n          let n = t;\n          r = r || \"undefined\" != typeof location && location, null == t && (t = r.protocol + \"//\" + r.host), \"string\" == typeof t && (\"/\" === t.charAt(0) && (t = \"/\" === t.charAt(1) ? r.protocol + t : r.host + t), /^(https?|wss?):\\/\\//.test(t) || (t = void 0 !== r ? r.protocol + \"//\" + t : \"https://\" + t), n = _(t)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = \"80\" : /^(http|ws)s$/.test(n.protocol) && (n.port = \"443\")), n.path = n.path || \"/\";\n          const o = -1 !== n.host.indexOf(\":\") ? \"[\" + n.host + \"]\" : n.host;\n          return n.id = n.protocol + \"://\" + o + \":\" + n.port + e, n.href = n.protocol + \"://\" + o + (r && r.port === n.port ? \"\" : \":\" + n.port), n;\n        }(t, (e = e || {}).path || \"/socket.io\"),\n        n = r.source,\n        o = r.id,\n        i = r.path,\n        s = Y[o] && i in Y[o].nsps;\n      let a;\n      return e.forceNew || e[\"force new connection\"] || !1 === e.multiplex || s ? a = new q(n, e) : (Y[o] || (Y[o] = new q(n, e)), a = Y[o]), r.query && !e.query && (e.query = r.queryKey), a.socket(r.path, e);\n    }\n    Object.assign(z, {\n      Manager: q,\n      Socket: I,\n      io: z,\n      connect: z\n    });\n    function V(t) {\n      return (V = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function H(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, (o = n.key, i = void 0, i = function (t, e) {\n          if (\"object\" !== V(t) || null === t) return t;\n          var r = t[Symbol.toPrimitive];\n          if (void 0 !== r) {\n            var n = r.call(t, e || \"default\");\n            if (\"object\" !== V(n)) return n;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          return (\"string\" === e ? String : Number)(t);\n        }(o, \"string\"), \"symbol\" === V(i) ? i : String(i)), n);\n      }\n      var o, i;\n    }\n    var K = function () {\n      function t(e) {\n        !function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, t), this.device_token = e, this.socket = null, this.socket_audio_transport, this.start();\n      }\n      var e, r, n;\n      return e = t, (r = [{\n        key: \"start\",\n        value: function () {\n          var t = this;\n          this.socket = z(\"https://devices.wavoip.com\", {\n            transports: [\"websocket\"],\n            path: \"/\".concat(this.device_token, \"/websocket\")\n          }), this.socket.on(\"audio_transport:create\", function (e) {\n            var r = e.room,\n              n = e.ip,\n              o = e.port;\n            console.info(\"[*] creating audio transport\"), t.socket_audio_transport = z(\"\".concat(n, \":\").concat(o, \"/call-\").concat(r), {\n              transports: [\"websocket\"],\n              path: \"/\".concat(t.device_token, \"/websocket\"),\n              forceNew: !0\n            });\n          }), this.socket.on(\"audio_transport:terminate\", function (t) {\n            t.room;\n          });\n        }\n      }]) && H(e.prototype, r), n && H(e, n), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n      }), t;\n    }();\n    function W(t) {\n      return (W = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    var J = function (t) {\n      return \"object\" === W(t) && \"success\" === (null == t ? void 0 : t.type);\n    };\n    function G(t) {\n      return (G = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function $(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, (o = n.key, i = void 0, i = function (t, e) {\n          if (\"object\" !== G(t) || null === t) return t;\n          var r = t[Symbol.toPrimitive];\n          if (void 0 !== r) {\n            var n = r.call(t, e || \"default\");\n            if (\"object\" !== G(n)) return n;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          return (\"string\" === e ? String : Number)(t);\n        }(o, \"string\"), \"symbol\" === G(i) ? i : String(i)), n);\n      }\n      var o, i;\n    }\n    var Q = function () {\n        function t(e) {\n          !function (t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), this.Socket = e;\n        }\n        var e, r, n;\n        return e = t, (r = [{\n          key: \"callStart\",\n          value: function (t) {\n            var e = this,\n              r = t.whatsappid;\n            return new Promise(function (t, n) {\n              try {\n                e.Socket.emit(\"calls:start\", r, function (e) {\n                  try {\n                    J(e), t(e);\n                  } catch (t) {\n                    n(t);\n                  }\n                });\n              } catch (t) {\n                n(t);\n              }\n            });\n          }\n        }, {\n          key: \"endCall\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              t.Socket.emit(\"calls:end\", {}, function (t) {\n                J(t) ? e(t) : r(t);\n              });\n            });\n          }\n        }, {\n          key: \"acceptCall\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              t.Socket.emit(\"calls:accept\", {}, function (t) {\n                J(t) ? e(t) : r(t);\n              });\n            });\n          }\n        }, {\n          key: \"rejectCall\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              t.Socket.emit(\"calls:reject\", {}, function (t) {\n                J(t) ? e(t) : r(t);\n              });\n            });\n          }\n        }, {\n          key: \"mute\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              t.Socket.emit(\"calls:mute\", {}, function (t) {\n                J(t) ? e(t) : r(t);\n              });\n            });\n          }\n        }, {\n          key: \"unMute\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              t.Socket.emit(\"calls:unmute\", {}, function (t) {\n                J(t) ? e(t) : r(t);\n              });\n            });\n          }\n        }]) && $(e.prototype, r), n && $(e, n), Object.defineProperty(e, \"prototype\", {\n          writable: !1\n        }), t;\n      }(),\n      X = r(17),\n      Z = r.n(X);\n    function tt(t) {\n      return (tt = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function et() {\n      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */et = function () {\n        return t;\n      };\n      var t = {},\n        e = Object.prototype,\n        r = e.hasOwnProperty,\n        n = Object.defineProperty || function (t, e, r) {\n          t[e] = r.value;\n        },\n        o = \"function\" == typeof Symbol ? Symbol : {},\n        i = o.iterator || \"@@iterator\",\n        s = o.asyncIterator || \"@@asyncIterator\",\n        a = o.toStringTag || \"@@toStringTag\";\n      function c(t, e, r) {\n        return Object.defineProperty(t, e, {\n          value: r,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }), t[e];\n      }\n      try {\n        c({}, \"\");\n      } catch (t) {\n        c = function (t, e, r) {\n          return t[e] = r;\n        };\n      }\n      function u(t, e, r, o) {\n        var i = e && e.prototype instanceof l ? e : l,\n          s = Object.create(i.prototype),\n          a = new k(o || []);\n        return n(s, \"_invoke\", {\n          value: E(t, r, a)\n        }), s;\n      }\n      function h(t, e, r) {\n        try {\n          return {\n            type: \"normal\",\n            arg: t.call(e, r)\n          };\n        } catch (t) {\n          return {\n            type: \"throw\",\n            arg: t\n          };\n        }\n      }\n      t.wrap = u;\n      var f = {};\n      function l() {}\n      function p() {}\n      function d() {}\n      var y = {};\n      c(y, i, function () {\n        return this;\n      });\n      var m = Object.getPrototypeOf,\n        g = m && m(m(A([])));\n      g && g !== e && r.call(g, i) && (y = g);\n      var v = d.prototype = l.prototype = Object.create(y);\n      function b(t) {\n        [\"next\", \"throw\", \"return\"].forEach(function (e) {\n          c(t, e, function (t) {\n            return this._invoke(e, t);\n          });\n        });\n      }\n      function w(t, e) {\n        var o;\n        n(this, \"_invoke\", {\n          value: function (n, i) {\n            function s() {\n              return new e(function (o, s) {\n                !function n(o, i, s, a) {\n                  var c = h(t[o], t, i);\n                  if (\"throw\" !== c.type) {\n                    var u = c.arg,\n                      f = u.value;\n                    return f && \"object\" == tt(f) && r.call(f, \"__await\") ? e.resolve(f.__await).then(function (t) {\n                      n(\"next\", t, s, a);\n                    }, function (t) {\n                      n(\"throw\", t, s, a);\n                    }) : e.resolve(f).then(function (t) {\n                      u.value = t, s(u);\n                    }, function (t) {\n                      return n(\"throw\", t, s, a);\n                    });\n                  }\n                  a(c.arg);\n                }(n, i, o, s);\n              });\n            }\n            return o = o ? o.then(s, s) : s();\n          }\n        });\n      }\n      function E(t, e, r) {\n        var n = \"suspendedStart\";\n        return function (o, i) {\n          if (\"executing\" === n) throw new Error(\"Generator is already running\");\n          if (\"completed\" === n) {\n            if (\"throw\" === o) throw i;\n            return R();\n          }\n          for (r.method = o, r.arg = i;;) {\n            var s = r.delegate;\n            if (s) {\n              var a = _(s, r);\n              if (a) {\n                if (a === f) continue;\n                return a;\n              }\n            }\n            if (\"next\" === r.method) r.sent = r._sent = r.arg;else if (\"throw\" === r.method) {\n              if (\"suspendedStart\" === n) throw n = \"completed\", r.arg;\n              r.dispatchException(r.arg);\n            } else \"return\" === r.method && r.abrupt(\"return\", r.arg);\n            n = \"executing\";\n            var c = h(t, e, r);\n            if (\"normal\" === c.type) {\n              if (n = r.done ? \"completed\" : \"suspendedYield\", c.arg === f) continue;\n              return {\n                value: c.arg,\n                done: r.done\n              };\n            }\n            \"throw\" === c.type && (n = \"completed\", r.method = \"throw\", r.arg = c.arg);\n          }\n        };\n      }\n      function _(t, e) {\n        var r = e.method,\n          n = t.iterator[r];\n        if (void 0 === n) return e.delegate = null, \"throw\" === r && t.iterator.return && (e.method = \"return\", e.arg = void 0, _(t, e), \"throw\" === e.method) || \"return\" !== r && (e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a '\" + r + \"' method\")), f;\n        var o = h(n, t.iterator, e.arg);\n        if (\"throw\" === o.type) return e.method = \"throw\", e.arg = o.arg, e.delegate = null, f;\n        var i = o.arg;\n        return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, \"return\" !== e.method && (e.method = \"next\", e.arg = void 0), e.delegate = null, f) : i : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, f);\n      }\n      function O(t) {\n        var e = {\n          tryLoc: t[0]\n        };\n        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n      }\n      function S(t) {\n        var e = t.completion || {};\n        e.type = \"normal\", delete e.arg, t.completion = e;\n      }\n      function k(t) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], t.forEach(O, this), this.reset(!0);\n      }\n      function A(t) {\n        if (t) {\n          var e = t[i];\n          if (e) return e.call(t);\n          if (\"function\" == typeof t.next) return t;\n          if (!isNaN(t.length)) {\n            var n = -1,\n              o = function e() {\n                for (; ++n < t.length;) if (r.call(t, n)) return e.value = t[n], e.done = !1, e;\n                return e.value = void 0, e.done = !0, e;\n              };\n            return o.next = o;\n          }\n        }\n        return {\n          next: R\n        };\n      }\n      function R() {\n        return {\n          value: void 0,\n          done: !0\n        };\n      }\n      return p.prototype = d, n(v, \"constructor\", {\n        value: d,\n        configurable: !0\n      }), n(d, \"constructor\", {\n        value: p,\n        configurable: !0\n      }), p.displayName = c(d, a, \"GeneratorFunction\"), t.isGeneratorFunction = function (t) {\n        var e = \"function\" == typeof t && t.constructor;\n        return !!e && (e === p || \"GeneratorFunction\" === (e.displayName || e.name));\n      }, t.mark = function (t) {\n        return Object.setPrototypeOf ? Object.setPrototypeOf(t, d) : (t.__proto__ = d, c(t, a, \"GeneratorFunction\")), t.prototype = Object.create(v), t;\n      }, t.awrap = function (t) {\n        return {\n          __await: t\n        };\n      }, b(w.prototype), c(w.prototype, s, function () {\n        return this;\n      }), t.AsyncIterator = w, t.async = function (e, r, n, o, i) {\n        void 0 === i && (i = Promise);\n        var s = new w(u(e, r, n, o), i);\n        return t.isGeneratorFunction(r) ? s : s.next().then(function (t) {\n          return t.done ? t.value : s.next();\n        });\n      }, b(v), c(v, a, \"Generator\"), c(v, i, function () {\n        return this;\n      }), c(v, \"toString\", function () {\n        return \"[object Generator]\";\n      }), t.keys = function (t) {\n        var e = Object(t),\n          r = [];\n        for (var n in e) r.push(n);\n        return r.reverse(), function t() {\n          for (; r.length;) {\n            var n = r.pop();\n            if (n in e) return t.value = n, t.done = !1, t;\n          }\n          return t.done = !0, t;\n        };\n      }, t.values = A, k.prototype = {\n        constructor: k,\n        reset: function (t) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = void 0, this.tryEntries.forEach(S), !t) for (var e in this) \"t\" === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0);\n        },\n        stop: function () {\n          this.done = !0;\n          var t = this.tryEntries[0].completion;\n          if (\"throw\" === t.type) throw t.arg;\n          return this.rval;\n        },\n        dispatchException: function (t) {\n          if (this.done) throw t;\n          var e = this;\n          function n(r, n) {\n            return s.type = \"throw\", s.arg = t, e.next = r, n && (e.method = \"next\", e.arg = void 0), !!n;\n          }\n          for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n            var i = this.tryEntries[o],\n              s = i.completion;\n            if (\"root\" === i.tryLoc) return n(\"end\");\n            if (i.tryLoc <= this.prev) {\n              var a = r.call(i, \"catchLoc\"),\n                c = r.call(i, \"finallyLoc\");\n              if (a && c) {\n                if (this.prev < i.catchLoc) return n(i.catchLoc, !0);\n                if (this.prev < i.finallyLoc) return n(i.finallyLoc);\n              } else if (a) {\n                if (this.prev < i.catchLoc) return n(i.catchLoc, !0);\n              } else {\n                if (!c) throw new Error(\"try statement without catch or finally\");\n                if (this.prev < i.finallyLoc) return n(i.finallyLoc);\n              }\n            }\n          }\n        },\n        abrupt: function (t, e) {\n          for (var n = this.tryEntries.length - 1; n >= 0; --n) {\n            var o = this.tryEntries[n];\n            if (o.tryLoc <= this.prev && r.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n              var i = o;\n              break;\n            }\n          }\n          i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n          var s = i ? i.completion : {};\n          return s.type = t, s.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, f) : this.complete(s);\n        },\n        complete: function (t, e) {\n          if (\"throw\" === t.type) throw t.arg;\n          return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), f;\n        },\n        finish: function (t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), S(r), f;\n          }\n        },\n        catch: function (t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.tryLoc === t) {\n              var n = r.completion;\n              if (\"throw\" === n.type) {\n                var o = n.arg;\n                S(r);\n              }\n              return o;\n            }\n          }\n          throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function (t, e, r) {\n          return this.delegate = {\n            iterator: A(t),\n            resultName: e,\n            nextLoc: r\n          }, \"next\" === this.method && (this.arg = void 0), f;\n        }\n      }, t;\n    }\n    function rt(t, e, r, n, o, i, s) {\n      try {\n        var a = t[i](s),\n          c = a.value;\n      } catch (t) {\n        return void r(t);\n      }\n      a.done ? e(c) : Promise.resolve(c).then(n, o);\n    }\n    function nt(t) {\n      return function () {\n        var e = this,\n          r = arguments;\n        return new Promise(function (n, o) {\n          var i = t.apply(e, r);\n          function s(t) {\n            rt(i, n, o, s, a, \"next\", t);\n          }\n          function a(t) {\n            rt(i, n, o, s, a, \"throw\", t);\n          }\n          s(void 0);\n        });\n      };\n    }\n    function ot(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, ct(n.key), n);\n      }\n    }\n    function it(t, e, r) {\n      return e && ot(t.prototype, e), r && ot(t, r), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), t;\n    }\n    function st(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function at(t, e, r) {\n      return (e = ct(e)) in t ? Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = r, t;\n    }\n    function ct(t) {\n      var e = function (t, e) {\n        if (\"object\" !== tt(t) || null === t) return t;\n        var r = t[Symbol.toPrimitive];\n        if (void 0 !== r) {\n          var n = r.call(t, e || \"default\");\n          if (\"object\" !== tt(n)) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === e ? String : Number)(t);\n      }(t, \"string\");\n      return \"symbol\" === tt(e) ? e : String(e);\n    }\n    var ut = it(function t() {\n      var e = this,\n        r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n        n = r.sampleRate,\n        o = r.numberOfChannels,\n        i = void 0 === o ? 1 : o,\n        s = r.latencyHint,\n        a = void 0 === s ? 0 : s,\n        c = r.workletOptions,\n        u = void 0 === c ? {} : c;\n      st(this, t), at(this, \"aw\", void 0), at(this, \"ac\", void 0), this.mediaStreamTrack = new Promise(function () {\n        var t = nt(et().mark(function t(r) {\n          var o, s;\n          return et().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                return o = new AudioContext({\n                  sampleRate: n,\n                  numberOfChannels: i,\n                  latencyHint: a,\n                  channelCount: 1,\n                  numberOfOutputs: 1\n                }), t.next = 3, o.suspend();\n              case 3:\n                return o.onstatechange = function (t) {\n                  console.log(t, \"ac.onstatechange\");\n                }, t.next = 6, o.audioWorklet.addModule(Z.a);\n              case 6:\n                (s = new AudioWorkletNode(o, \"audio-data-worklet-stream\", u)).connect(o.destination), o.resume(), e.aw = s, e.ac = o, r();\n              case 12:\n              case \"end\":\n                return t.stop();\n            }\n          }, t);\n        }));\n        return function (e) {\n          return t.apply(this, arguments);\n        };\n      }());\n    });\n    function ht(t) {\n      return (ht = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function ft(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, pt(n.key), n);\n      }\n    }\n    function lt(t, e, r) {\n      return (e = pt(e)) in t ? Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = r, t;\n    }\n    function pt(t) {\n      var e = function (t, e) {\n        if (\"object\" !== ht(t) || null === t) return t;\n        var r = t[Symbol.toPrimitive];\n        if (void 0 !== r) {\n          var n = r.call(t, e || \"default\");\n          if (\"object\" !== ht(n)) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === e ? String : Number)(t);\n      }(t, \"string\");\n      return \"symbol\" === ht(e) ? e : String(e);\n    }\n    var dt = function () {\n        function t(e, r) {\n          !function (t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), lt(this, \"audioCtx\", new (window.AudioContext || window.webkitAudioContext)()), lt(this, \"workletStream\", void 0), lt(this, \"deviceEmitter\", void 0), lt(this, \"isStarted\", !1), this.Socket = e, this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(), this.workletStream, this.deviceEmitter = r, this.isStarted = !1;\n        }\n        var e, r, n;\n        return e = t, (r = [{\n          key: \"start\",\n          value: function (t) {\n            var e = this,\n              r = new ut({\n                sampleRate: t,\n                latencyHint: 0,\n                workletOptions: {\n                  numberOfInputs: 1,\n                  numberOfOutputs: 1,\n                  channelCount: 1,\n                  processorOptions: {\n                    offset: 0\n                  }\n                }\n              });\n            this.Socket.socket_audio_transport.on(\"audio_buffer\", function (t) {\n              var e = new Uint8Array(t);\n              r.aw.port.postMessage({\n                buffer: e\n              });\n            }), this.workletStream = r, this.workletStream.mediaStreamTrack.finally(function () {\n              e.workletStream.ac.onstatechange = function () {\n                var t;\n                e.deviceEmitter.emit(\"audio_audioctx_change_state\", {\n                  audio_context: e.workletStream.ac,\n                  state: null === (t = e.workletStream) || void 0 === t || null === (t = t.ac) || void 0 === t ? void 0 : t.state\n                });\n              };\n            }), this.isStarted = !0, this.checkPermission();\n          }\n        }, {\n          key: \"stop\",\n          value: function () {\n            console.info(\"[*] - Audio stream stopped\"), this.workletStream = null, this.Socket.socket_audio_transport && this.Socket.socket_audio_transport.off(\"audio_buffer\"), this.isStarted = !1;\n          }\n        }, {\n          key: \"checkPermission\",\n          value: function () {\n            var t,\n              e,\n              r = this;\n            this.isStarted && (navigator.userActivation.hasBeenActive && null !== (t = this.workletStream) && void 0 !== t && t.ac ? null === (e = this.workletStream) || void 0 === e || e.ac.resume().then(function () {\n              return console.log(\"[AUDIO] - Permission success to access audio device\"), !0;\n            }).catch(function (t) {\n              console.error(\"[AUDIO] - Permission error to access audio device\", t), setTimeout(function () {\n                r.checkPermission();\n              }, 250);\n            }) : setTimeout(function () {\n              r.checkPermission();\n            }, 250));\n          }\n        }, {\n          key: \"checkError\",\n          value: function () {\n            return navigator.userActivation.hasBeenActive ? null !== (t = this.workletStream) && void 0 !== t && t.ac && \"running\" !== this.workletStream.ac.state ? {\n              type: \"audio_context\",\n              message: \"No foi possvel obter acesso ao dspositivo de audio\"\n            } : null : {\n              type: \"audio_context\",\n              message: \"Voc precisa interagir com a pgina para liberar a permisso de udio\"\n            };\n            var t;\n          }\n        }]) && ft(e.prototype, r), n && ft(e, n), Object.defineProperty(e, \"prototype\", {\n          writable: !1\n        }), t;\n      }(),\n      yt = r(0),\n      mt = r(12),\n      gt = r(7);\n    function vt(t) {\n      const e = {\n        \"!\": \"%21\",\n        \"'\": \"%27\",\n        \"(\": \"%28\",\n        \")\": \"%29\",\n        \"~\": \"%7E\",\n        \"%20\": \"+\",\n        \"%00\": \"\\0\"\n      };\n      return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {\n        return e[t];\n      });\n    }\n    function bt(t, e) {\n      this._pairs = [], t && Object(gt.a)(t, this, e);\n    }\n    const wt = bt.prototype;\n    wt.append = function (t, e) {\n      this._pairs.push([t, e]);\n    }, wt.toString = function (t) {\n      const e = t ? function (e) {\n        return t.call(this, e, vt);\n      } : vt;\n      return this._pairs.map(function (t) {\n        return e(t[0]) + \"=\" + e(t[1]);\n      }, \"\").join(\"&\");\n    };\n    var Et = bt;\n    function _t(t) {\n      return encodeURIComponent(t).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n    }\n    function Ot(t, e, r) {\n      if (!e) return t;\n      const n = r && r.encode || _t,\n        o = r && r.serialize;\n      let i;\n      if (i = o ? o(e, r) : yt.a.isURLSearchParams(e) ? e.toString() : new Et(e, r).toString(n), i) {\n        const e = t.indexOf(\"#\");\n        -1 !== e && (t = t.slice(0, e)), t += (-1 === t.indexOf(\"?\") ? \"?\" : \"&\") + i;\n      }\n      return t;\n    }\n    var St = class {\n        constructor() {\n          this.handlers = [];\n        }\n        use(t, e, r) {\n          return this.handlers.push({\n            fulfilled: t,\n            rejected: e,\n            synchronous: !!r && r.synchronous,\n            runWhen: r ? r.runWhen : null\n          }), this.handlers.length - 1;\n        }\n        eject(t) {\n          this.handlers[t] && (this.handlers[t] = null);\n        }\n        clear() {\n          this.handlers && (this.handlers = []);\n        }\n        forEach(t) {\n          yt.a.forEach(this.handlers, function (e) {\n            null !== e && t(e);\n          });\n        }\n      },\n      kt = r(1),\n      At = {\n        silentJSONParsing: !0,\n        forcedJSONParsing: !0,\n        clarifyTimeoutError: !1\n      },\n      Rt = \"undefined\" != typeof URLSearchParams ? URLSearchParams : Et,\n      xt = FormData;\n    const Tt = (() => {\n      let t;\n      return (\"undefined\" == typeof navigator || \"ReactNative\" !== (t = navigator.product) && \"NativeScript\" !== t && \"NS\" !== t) && \"undefined\" != typeof window && \"undefined\" != typeof document;\n    })();\n    var Pt = {\n      isBrowser: !0,\n      classes: {\n        URLSearchParams: Rt,\n        FormData: xt,\n        Blob: Blob\n      },\n      isStandardBrowserEnv: Tt,\n      protocols: [\"http\", \"https\", \"file\", \"blob\", \"url\", \"data\"]\n    };\n    var jt = function (t) {\n      function e(t, r, n, o) {\n        let i = t[o++];\n        const s = Number.isFinite(+i),\n          a = o >= t.length;\n        if (i = !i && yt.a.isArray(n) ? n.length : i, a) return yt.a.hasOwnProp(n, i) ? n[i] = [n[i], r] : n[i] = r, !s;\n        n[i] && yt.a.isObject(n[i]) || (n[i] = []);\n        return e(t, r, n[i], o) && yt.a.isArray(n[i]) && (n[i] = function (t) {\n          const e = {},\n            r = Object.keys(t);\n          let n;\n          const o = r.length;\n          let i;\n          for (n = 0; n < o; n++) i = r[n], e[i] = t[i];\n          return e;\n        }(n[i])), !s;\n      }\n      if (yt.a.isFormData(t) && yt.a.isFunction(t.entries)) {\n        const r = {};\n        return yt.a.forEachEntry(t, (t, n) => {\n          e(function (t) {\n            return yt.a.matchAll(/\\w+|\\[(\\w*)]/g, t).map(t => \"[]\" === t[0] ? \"\" : t[1] || t[0]);\n          }(t), n, r, 0);\n        }), r;\n      }\n      return null;\n    };\n    const Ct = {\n      \"Content-Type\": void 0\n    };\n    const Bt = {\n      transitional: At,\n      adapter: [\"xhr\", \"http\"],\n      transformRequest: [function (t, e) {\n        const r = e.getContentType() || \"\",\n          n = r.indexOf(\"application/json\") > -1,\n          o = yt.a.isObject(t);\n        o && yt.a.isHTMLForm(t) && (t = new FormData(t));\n        if (yt.a.isFormData(t)) return n && n ? JSON.stringify(jt(t)) : t;\n        if (yt.a.isArrayBuffer(t) || yt.a.isBuffer(t) || yt.a.isStream(t) || yt.a.isFile(t) || yt.a.isBlob(t)) return t;\n        if (yt.a.isArrayBufferView(t)) return t.buffer;\n        if (yt.a.isURLSearchParams(t)) return e.setContentType(\"application/x-www-form-urlencoded;charset=utf-8\", !1), t.toString();\n        let i;\n        if (o) {\n          if (r.indexOf(\"application/x-www-form-urlencoded\") > -1) return function (t, e) {\n            return Object(gt.a)(t, new Pt.classes.URLSearchParams(), Object.assign({\n              visitor: function (t, e, r, n) {\n                return Pt.isNode && yt.a.isBuffer(t) ? (this.append(e, t.toString(\"base64\")), !1) : n.defaultVisitor.apply(this, arguments);\n              }\n            }, e));\n          }(t, this.formSerializer).toString();\n          if ((i = yt.a.isFileList(t)) || r.indexOf(\"multipart/form-data\") > -1) {\n            const e = this.env && this.env.FormData;\n            return Object(gt.a)(i ? {\n              \"files[]\": t\n            } : t, e && new e(), this.formSerializer);\n          }\n        }\n        return o || n ? (e.setContentType(\"application/json\", !1), function (t, e, r) {\n          if (yt.a.isString(t)) try {\n            return (e || JSON.parse)(t), yt.a.trim(t);\n          } catch (t) {\n            if (\"SyntaxError\" !== t.name) throw t;\n          }\n          return (r || JSON.stringify)(t);\n        }(t)) : t;\n      }],\n      transformResponse: [function (t) {\n        const e = this.transitional || Bt.transitional,\n          r = e && e.forcedJSONParsing,\n          n = \"json\" === this.responseType;\n        if (t && yt.a.isString(t) && (r && !this.responseType || n)) {\n          const r = !(e && e.silentJSONParsing) && n;\n          try {\n            return JSON.parse(t);\n          } catch (t) {\n            if (r) {\n              if (\"SyntaxError\" === t.name) throw kt.a.from(t, kt.a.ERR_BAD_RESPONSE, this, null, this.response);\n              throw t;\n            }\n          }\n        }\n        return t;\n      }],\n      timeout: 0,\n      xsrfCookieName: \"XSRF-TOKEN\",\n      xsrfHeaderName: \"X-XSRF-TOKEN\",\n      maxContentLength: -1,\n      maxBodyLength: -1,\n      env: {\n        FormData: Pt.classes.FormData,\n        Blob: Pt.classes.Blob\n      },\n      validateStatus: function (t) {\n        return t >= 200 && t < 300;\n      },\n      headers: {\n        common: {\n          Accept: \"application/json, text/plain, */*\"\n        }\n      }\n    };\n    yt.a.forEach([\"delete\", \"get\", \"head\"], function (t) {\n      Bt.headers[t] = {};\n    }), yt.a.forEach([\"post\", \"put\", \"patch\"], function (t) {\n      Bt.headers[t] = yt.a.merge(Ct);\n    });\n    var Lt = Bt;\n    const Nt = yt.a.toObjectSet([\"age\", \"authorization\", \"content-length\", \"content-type\", \"etag\", \"expires\", \"from\", \"host\", \"if-modified-since\", \"if-unmodified-since\", \"last-modified\", \"location\", \"max-forwards\", \"proxy-authorization\", \"referer\", \"retry-after\", \"user-agent\"]);\n    const Ut = Symbol(\"internals\");\n    function Dt(t) {\n      return t && String(t).trim().toLowerCase();\n    }\n    function Mt(t) {\n      return !1 === t || null == t ? t : yt.a.isArray(t) ? t.map(Mt) : String(t);\n    }\n    function It(t, e, r, n) {\n      return yt.a.isFunction(n) ? n.call(this, e, r) : yt.a.isString(e) ? yt.a.isString(n) ? -1 !== e.indexOf(n) : yt.a.isRegExp(n) ? n.test(e) : void 0 : void 0;\n    }\n    class Ft {\n      constructor(t) {\n        t && this.set(t);\n      }\n      set(t, e, r) {\n        const n = this;\n        function o(t, e, r) {\n          const o = Dt(e);\n          if (!o) throw new Error(\"header name must be a non-empty string\");\n          const i = yt.a.findKey(n, o);\n          (!i || void 0 === n[i] || !0 === r || void 0 === r && !1 !== n[i]) && (n[i || e] = Mt(t));\n        }\n        const i = (t, e) => yt.a.forEach(t, (t, r) => o(t, r, e));\n        return yt.a.isPlainObject(t) || t instanceof this.constructor ? i(t, e) : yt.a.isString(t) && (t = t.trim()) && !/^[-_a-zA-Z]+$/.test(t.trim()) ? i((t => {\n          const e = {};\n          let r, n, o;\n          return t && t.split(\"\\n\").forEach(function (t) {\n            o = t.indexOf(\":\"), r = t.substring(0, o).trim().toLowerCase(), n = t.substring(o + 1).trim(), !r || e[r] && Nt[r] || (\"set-cookie\" === r ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + \", \" + n : n);\n          }), e;\n        })(t), e) : null != t && o(e, t, r), this;\n      }\n      get(t, e) {\n        if (t = Dt(t)) {\n          const r = yt.a.findKey(this, t);\n          if (r) {\n            const t = this[r];\n            if (!e) return t;\n            if (!0 === e) return function (t) {\n              const e = Object.create(null),\n                r = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n              let n;\n              for (; n = r.exec(t);) e[n[1]] = n[2];\n              return e;\n            }(t);\n            if (yt.a.isFunction(e)) return e.call(this, t, r);\n            if (yt.a.isRegExp(e)) return e.exec(t);\n            throw new TypeError(\"parser must be boolean|regexp|function\");\n          }\n        }\n      }\n      has(t, e) {\n        if (t = Dt(t)) {\n          const r = yt.a.findKey(this, t);\n          return !(!r || e && !It(0, this[r], r, e));\n        }\n        return !1;\n      }\n      delete(t, e) {\n        const r = this;\n        let n = !1;\n        function o(t) {\n          if (t = Dt(t)) {\n            const o = yt.a.findKey(r, t);\n            !o || e && !It(0, r[o], o, e) || (delete r[o], n = !0);\n          }\n        }\n        return yt.a.isArray(t) ? t.forEach(o) : o(t), n;\n      }\n      clear() {\n        return Object.keys(this).forEach(this.delete.bind(this));\n      }\n      normalize(t) {\n        const e = this,\n          r = {};\n        return yt.a.forEach(this, (n, o) => {\n          const i = yt.a.findKey(r, o);\n          if (i) return e[i] = Mt(n), void delete e[o];\n          const s = t ? function (t) {\n            return t.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, (t, e, r) => e.toUpperCase() + r);\n          }(o) : String(o).trim();\n          s !== o && delete e[o], e[s] = Mt(n), r[s] = !0;\n        }), this;\n      }\n      concat() {\n        for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n          t[_key8] = arguments[_key8];\n        }\n        return this.constructor.concat(this, ...t);\n      }\n      toJSON(t) {\n        const e = Object.create(null);\n        return yt.a.forEach(this, (r, n) => {\n          null != r && !1 !== r && (e[n] = t && yt.a.isArray(r) ? r.join(\", \") : r);\n        }), e;\n      }\n      [Symbol.iterator]() {\n        return Object.entries(this.toJSON())[Symbol.iterator]();\n      }\n      toString() {\n        return Object.entries(this.toJSON()).map(_ref3 => {\n          let [t, e] = _ref3;\n          return t + \": \" + e;\n        }).join(\"\\n\");\n      }\n      get [Symbol.toStringTag]() {\n        return \"AxiosHeaders\";\n      }\n      static from(t) {\n        return t instanceof this ? t : new this(t);\n      }\n      static concat(t) {\n        const r = new this(t);\n        for (var _len9 = arguments.length, e = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n          e[_key9 - 1] = arguments[_key9];\n        }\n        return e.forEach(t => r.set(t)), r;\n      }\n      static accessor(t) {\n        const e = (this[Ut] = this[Ut] = {\n            accessors: {}\n          }).accessors,\n          r = this.prototype;\n        function n(t) {\n          const n = Dt(t);\n          e[n] || (!function (t, e) {\n            const r = yt.a.toCamelCase(\" \" + e);\n            [\"get\", \"set\", \"has\"].forEach(n => {\n              Object.defineProperty(t, n + r, {\n                value: function (t, r, o) {\n                  return this[n].call(this, e, t, r, o);\n                },\n                configurable: !0\n              });\n            });\n          }(r, t), e[n] = !0);\n        }\n        return yt.a.isArray(t) ? t.forEach(n) : n(t), this;\n      }\n    }\n    Ft.accessor([\"Content-Type\", \"Content-Length\", \"Accept\", \"Accept-Encoding\", \"User-Agent\"]), yt.a.freezeMethods(Ft.prototype), yt.a.freezeMethods(Ft);\n    var qt = Ft;\n    function Yt(t, e) {\n      const r = this || Lt,\n        n = e || r,\n        o = qt.from(n.headers);\n      let i = n.data;\n      return yt.a.forEach(t, function (t) {\n        i = t.call(r, i, o.normalize(), e ? e.status : void 0);\n      }), o.normalize(), i;\n    }\n    function zt(t) {\n      return !(!t || !t.__CANCEL__);\n    }\n    function Vt(t, e, r) {\n      kt.a.call(this, null == t ? \"canceled\" : t, kt.a.ERR_CANCELED, e, r), this.name = \"CanceledError\";\n    }\n    yt.a.inherits(Vt, kt.a, {\n      __CANCEL__: !0\n    });\n    var Ht = Vt;\n    var Kt = Pt.isStandardBrowserEnv ? {\n      write: function (t, e, r, n, o, i) {\n        const s = [];\n        s.push(t + \"=\" + encodeURIComponent(e)), yt.a.isNumber(r) && s.push(\"expires=\" + new Date(r).toGMTString()), yt.a.isString(n) && s.push(\"path=\" + n), yt.a.isString(o) && s.push(\"domain=\" + o), !0 === i && s.push(\"secure\"), document.cookie = s.join(\"; \");\n      },\n      read: function (t) {\n        const e = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + t + \")=([^;]*)\"));\n        return e ? decodeURIComponent(e[3]) : null;\n      },\n      remove: function (t) {\n        this.write(t, \"\", Date.now() - 864e5);\n      }\n    } : {\n      write: function () {},\n      read: function () {\n        return null;\n      },\n      remove: function () {}\n    };\n    function Wt(t, e) {\n      return t && !/^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(e) ? function (t, e) {\n        return e ? t.replace(/\\/+$/, \"\") + \"/\" + e.replace(/^\\/+/, \"\") : t;\n      }(t, e) : e;\n    }\n    var Jt = Pt.isStandardBrowserEnv ? function () {\n      const t = /(msie|trident)/i.test(navigator.userAgent),\n        e = document.createElement(\"a\");\n      let r;\n      function n(r) {\n        let n = r;\n        return t && (e.setAttribute(\"href\", n), n = e.href), e.setAttribute(\"href\", n), {\n          href: e.href,\n          protocol: e.protocol ? e.protocol.replace(/:$/, \"\") : \"\",\n          host: e.host,\n          search: e.search ? e.search.replace(/^\\?/, \"\") : \"\",\n          hash: e.hash ? e.hash.replace(/^#/, \"\") : \"\",\n          hostname: e.hostname,\n          port: e.port,\n          pathname: \"/\" === e.pathname.charAt(0) ? e.pathname : \"/\" + e.pathname\n        };\n      }\n      return r = n(window.location.href), function (t) {\n        const e = yt.a.isString(t) ? n(t) : t;\n        return e.protocol === r.protocol && e.host === r.host;\n      };\n    }() : function () {\n      return !0;\n    };\n    var Gt = function (t, e) {\n      t = t || 10;\n      const r = new Array(t),\n        n = new Array(t);\n      let o,\n        i = 0,\n        s = 0;\n      return e = void 0 !== e ? e : 1e3, function (a) {\n        const c = Date.now(),\n          u = n[s];\n        o || (o = c), r[i] = a, n[i] = c;\n        let h = s,\n          f = 0;\n        for (; h !== i;) f += r[h++], h %= t;\n        if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - o < e) return;\n        const l = u && c - u;\n        return l ? Math.round(1e3 * f / l) : void 0;\n      };\n    };\n    function $t(t, e) {\n      let r = 0;\n      const n = Gt(50, 250);\n      return o => {\n        const i = o.loaded,\n          s = o.lengthComputable ? o.total : void 0,\n          a = i - r,\n          c = n(a);\n        r = i;\n        const u = {\n          loaded: i,\n          total: s,\n          progress: s ? i / s : void 0,\n          bytes: a,\n          rate: c || void 0,\n          estimated: c && s && i <= s ? (s - i) / c : void 0,\n          event: o\n        };\n        u[e ? \"download\" : \"upload\"] = !0, t(u);\n      };\n    }\n    const Qt = {\n      http: null,\n      xhr: \"undefined\" != typeof XMLHttpRequest && function (t) {\n        return new Promise(function (e, r) {\n          let n = t.data;\n          const o = qt.from(t.headers).normalize(),\n            i = t.responseType;\n          let s;\n          function a() {\n            t.cancelToken && t.cancelToken.unsubscribe(s), t.signal && t.signal.removeEventListener(\"abort\", s);\n          }\n          yt.a.isFormData(n) && Pt.isStandardBrowserEnv && o.setContentType(!1);\n          let c = new XMLHttpRequest();\n          if (t.auth) {\n            const e = t.auth.username || \"\",\n              r = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : \"\";\n            o.set(\"Authorization\", \"Basic \" + btoa(e + \":\" + r));\n          }\n          const u = Wt(t.baseURL, t.url);\n          function h() {\n            if (!c) return;\n            const n = qt.from(\"getAllResponseHeaders\" in c && c.getAllResponseHeaders());\n            !function (t, e, r) {\n              const n = r.config.validateStatus;\n              r.status && n && !n(r.status) ? e(new kt.a(\"Request failed with status code \" + r.status, [kt.a.ERR_BAD_REQUEST, kt.a.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r)) : t(r);\n            }(function (t) {\n              e(t), a();\n            }, function (t) {\n              r(t), a();\n            }, {\n              data: i && \"text\" !== i && \"json\" !== i ? c.response : c.responseText,\n              status: c.status,\n              statusText: c.statusText,\n              headers: n,\n              config: t,\n              request: c\n            }), c = null;\n          }\n          if (c.open(t.method.toUpperCase(), Ot(u, t.params, t.paramsSerializer), !0), c.timeout = t.timeout, \"onloadend\" in c ? c.onloadend = h : c.onreadystatechange = function () {\n            c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf(\"file:\")) && setTimeout(h);\n          }, c.onabort = function () {\n            c && (r(new kt.a(\"Request aborted\", kt.a.ECONNABORTED, t, c)), c = null);\n          }, c.onerror = function () {\n            r(new kt.a(\"Network Error\", kt.a.ERR_NETWORK, t, c)), c = null;\n          }, c.ontimeout = function () {\n            let e = t.timeout ? \"timeout of \" + t.timeout + \"ms exceeded\" : \"timeout exceeded\";\n            const n = t.transitional || At;\n            t.timeoutErrorMessage && (e = t.timeoutErrorMessage), r(new kt.a(e, n.clarifyTimeoutError ? kt.a.ETIMEDOUT : kt.a.ECONNABORTED, t, c)), c = null;\n          }, Pt.isStandardBrowserEnv) {\n            const e = (t.withCredentials || Jt(u)) && t.xsrfCookieName && Kt.read(t.xsrfCookieName);\n            e && o.set(t.xsrfHeaderName, e);\n          }\n          void 0 === n && o.setContentType(null), \"setRequestHeader\" in c && yt.a.forEach(o.toJSON(), function (t, e) {\n            c.setRequestHeader(e, t);\n          }), yt.a.isUndefined(t.withCredentials) || (c.withCredentials = !!t.withCredentials), i && \"json\" !== i && (c.responseType = t.responseType), \"function\" == typeof t.onDownloadProgress && c.addEventListener(\"progress\", $t(t.onDownloadProgress, !0)), \"function\" == typeof t.onUploadProgress && c.upload && c.upload.addEventListener(\"progress\", $t(t.onUploadProgress)), (t.cancelToken || t.signal) && (s = e => {\n            c && (r(!e || e.type ? new Ht(null, t, c) : e), c.abort(), c = null);\n          }, t.cancelToken && t.cancelToken.subscribe(s), t.signal && (t.signal.aborted ? s() : t.signal.addEventListener(\"abort\", s)));\n          const f = function (t) {\n            const e = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(t);\n            return e && e[1] || \"\";\n          }(u);\n          f && -1 === Pt.protocols.indexOf(f) ? r(new kt.a(\"Unsupported protocol \" + f + \":\", kt.a.ERR_BAD_REQUEST, t)) : c.send(n || null);\n        });\n      }\n    };\n    yt.a.forEach(Qt, (t, e) => {\n      if (t) {\n        try {\n          Object.defineProperty(t, \"name\", {\n            value: e\n          });\n        } catch (t) {}\n        Object.defineProperty(t, \"adapterName\", {\n          value: e\n        });\n      }\n    });\n    var Xt = t => {\n      t = yt.a.isArray(t) ? t : [t];\n      const {\n        length: e\n      } = t;\n      let r, n;\n      for (let o = 0; o < e && (r = t[o], !(n = yt.a.isString(r) ? Qt[r.toLowerCase()] : r)); o++);\n      if (!n) {\n        if (!1 === n) throw new kt.a(\"Adapter \".concat(r, \" is not supported by the environment\"), \"ERR_NOT_SUPPORT\");\n        throw new Error(yt.a.hasOwnProp(Qt, r) ? \"Adapter '\".concat(r, \"' is not available in the build\") : \"Unknown adapter '\".concat(r, \"'\"));\n      }\n      if (!yt.a.isFunction(n)) throw new TypeError(\"adapter is not a function\");\n      return n;\n    };\n    function Zt(t) {\n      if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Ht();\n    }\n    function te(t) {\n      Zt(t), t.headers = qt.from(t.headers), t.data = Yt.call(t, t.transformRequest), -1 !== [\"post\", \"put\", \"patch\"].indexOf(t.method) && t.headers.setContentType(\"application/x-www-form-urlencoded\", !1);\n      return Xt(t.adapter || Lt.adapter)(t).then(function (e) {\n        return Zt(t), e.data = Yt.call(t, t.transformResponse, e), e.headers = qt.from(e.headers), e;\n      }, function (e) {\n        return zt(e) || (Zt(t), e && e.response && (e.response.data = Yt.call(t, t.transformResponse, e.response), e.response.headers = qt.from(e.response.headers))), Promise.reject(e);\n      });\n    }\n    const ee = t => t instanceof qt ? t.toJSON() : t;\n    function re(t, e) {\n      e = e || {};\n      const r = {};\n      function n(t, e, r) {\n        return yt.a.isPlainObject(t) && yt.a.isPlainObject(e) ? yt.a.merge.call({\n          caseless: r\n        }, t, e) : yt.a.isPlainObject(e) ? yt.a.merge({}, e) : yt.a.isArray(e) ? e.slice() : e;\n      }\n      function o(t, e, r) {\n        return yt.a.isUndefined(e) ? yt.a.isUndefined(t) ? void 0 : n(void 0, t, r) : n(t, e, r);\n      }\n      function i(t, e) {\n        if (!yt.a.isUndefined(e)) return n(void 0, e);\n      }\n      function s(t, e) {\n        return yt.a.isUndefined(e) ? yt.a.isUndefined(t) ? void 0 : n(void 0, t) : n(void 0, e);\n      }\n      function a(r, o, i) {\n        return i in e ? n(r, o) : i in t ? n(void 0, r) : void 0;\n      }\n      const c = {\n        url: i,\n        method: i,\n        data: i,\n        baseURL: s,\n        transformRequest: s,\n        transformResponse: s,\n        paramsSerializer: s,\n        timeout: s,\n        timeoutMessage: s,\n        withCredentials: s,\n        adapter: s,\n        responseType: s,\n        xsrfCookieName: s,\n        xsrfHeaderName: s,\n        onUploadProgress: s,\n        onDownloadProgress: s,\n        decompress: s,\n        maxContentLength: s,\n        maxBodyLength: s,\n        beforeRedirect: s,\n        transport: s,\n        httpAgent: s,\n        httpsAgent: s,\n        cancelToken: s,\n        socketPath: s,\n        responseEncoding: s,\n        validateStatus: a,\n        headers: (t, e) => o(ee(t), ee(e), !0)\n      };\n      return yt.a.forEach(Object.keys(t).concat(Object.keys(e)), function (n) {\n        const i = c[n] || o,\n          s = i(t[n], e[n], n);\n        yt.a.isUndefined(s) && i !== a || (r[n] = s);\n      }), r;\n    }\n    const ne = {};\n    [\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach((t, e) => {\n      ne[t] = function (r) {\n        return typeof r === t || \"a\" + (e < 1 ? \"n \" : \" \") + t;\n      };\n    });\n    const oe = {};\n    ne.transitional = function (t, e, r) {\n      function n(t, e) {\n        return \"[Axios v1.2.0] Transitional option '\" + t + \"'\" + e + (r ? \". \" + r : \"\");\n      }\n      return (r, o, i) => {\n        if (!1 === t) throw new kt.a(n(o, \" has been removed\" + (e ? \" in \" + e : \"\")), kt.a.ERR_DEPRECATED);\n        return e && !oe[o] && (oe[o] = !0, console.warn(n(o, \" has been deprecated since v\" + e + \" and will be removed in the near future\"))), !t || t(r, o, i);\n      };\n    };\n    var ie = {\n      assertOptions: function (t, e, r) {\n        if (\"object\" != typeof t) throw new kt.a(\"options must be an object\", kt.a.ERR_BAD_OPTION_VALUE);\n        const n = Object.keys(t);\n        let o = n.length;\n        for (; o-- > 0;) {\n          const i = n[o],\n            s = e[i];\n          if (s) {\n            const e = t[i],\n              r = void 0 === e || s(e, i, t);\n            if (!0 !== r) throw new kt.a(\"option \" + i + \" must be \" + r, kt.a.ERR_BAD_OPTION_VALUE);\n          } else if (!0 !== r) throw new kt.a(\"Unknown option \" + i, kt.a.ERR_BAD_OPTION);\n        }\n      },\n      validators: ne\n    };\n    const se = ie.validators;\n    class ae {\n      constructor(t) {\n        this.defaults = t, this.interceptors = {\n          request: new St(),\n          response: new St()\n        };\n      }\n      request(t, e) {\n        \"string\" == typeof t ? (e = e || {}).url = t : e = t || {}, e = re(this.defaults, e);\n        const {\n          transitional: r,\n          paramsSerializer: n,\n          headers: o\n        } = e;\n        let i;\n        void 0 !== r && ie.assertOptions(r, {\n          silentJSONParsing: se.transitional(se.boolean),\n          forcedJSONParsing: se.transitional(se.boolean),\n          clarifyTimeoutError: se.transitional(se.boolean)\n        }, !1), void 0 !== n && ie.assertOptions(n, {\n          encode: se.function,\n          serialize: se.function\n        }, !0), e.method = (e.method || this.defaults.method || \"get\").toLowerCase(), i = o && yt.a.merge(o.common, o[e.method]), i && yt.a.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"], t => {\n          delete o[t];\n        }), e.headers = qt.concat(i, o);\n        const s = [];\n        let a = !0;\n        this.interceptors.request.forEach(function (t) {\n          \"function\" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous, s.unshift(t.fulfilled, t.rejected));\n        });\n        const c = [];\n        let u;\n        this.interceptors.response.forEach(function (t) {\n          c.push(t.fulfilled, t.rejected);\n        });\n        let h,\n          f = 0;\n        if (!a) {\n          const t = [te.bind(this), void 0];\n          for (t.unshift.apply(t, s), t.push.apply(t, c), h = t.length, u = Promise.resolve(e); f < h;) u = u.then(t[f++], t[f++]);\n          return u;\n        }\n        h = s.length;\n        let l = e;\n        for (f = 0; f < h;) {\n          const t = s[f++],\n            e = s[f++];\n          try {\n            l = t(l);\n          } catch (t) {\n            e.call(this, t);\n            break;\n          }\n        }\n        try {\n          u = te.call(this, l);\n        } catch (t) {\n          return Promise.reject(t);\n        }\n        for (f = 0, h = c.length; f < h;) u = u.then(c[f++], c[f++]);\n        return u;\n      }\n      getUri(t) {\n        return Ot(Wt((t = re(this.defaults, t)).baseURL, t.url), t.params, t.paramsSerializer);\n      }\n    }\n    yt.a.forEach([\"delete\", \"get\", \"head\", \"options\"], function (t) {\n      ae.prototype[t] = function (e, r) {\n        return this.request(re(r || {}, {\n          method: t,\n          url: e,\n          data: (r || {}).data\n        }));\n      };\n    }), yt.a.forEach([\"post\", \"put\", \"patch\"], function (t) {\n      function e(e) {\n        return function (r, n, o) {\n          return this.request(re(o || {}, {\n            method: t,\n            headers: e ? {\n              \"Content-Type\": \"multipart/form-data\"\n            } : {},\n            url: r,\n            data: n\n          }));\n        };\n      }\n      ae.prototype[t] = e(), ae.prototype[t + \"Form\"] = e(!0);\n    });\n    var ce = ae;\n    class ue {\n      constructor(t) {\n        if (\"function\" != typeof t) throw new TypeError(\"executor must be a function.\");\n        let e;\n        this.promise = new Promise(function (t) {\n          e = t;\n        });\n        const r = this;\n        this.promise.then(t => {\n          if (!r._listeners) return;\n          let e = r._listeners.length;\n          for (; e-- > 0;) r._listeners[e](t);\n          r._listeners = null;\n        }), this.promise.then = t => {\n          let e;\n          const n = new Promise(t => {\n            r.subscribe(t), e = t;\n          }).then(t);\n          return n.cancel = function () {\n            r.unsubscribe(e);\n          }, n;\n        }, t(function (t, n, o) {\n          r.reason || (r.reason = new Ht(t, n, o), e(r.reason));\n        });\n      }\n      throwIfRequested() {\n        if (this.reason) throw this.reason;\n      }\n      subscribe(t) {\n        this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : this._listeners = [t];\n      }\n      unsubscribe(t) {\n        if (!this._listeners) return;\n        const e = this._listeners.indexOf(t);\n        -1 !== e && this._listeners.splice(e, 1);\n      }\n      static source() {\n        let t;\n        return {\n          token: new ue(function (e) {\n            t = e;\n          }),\n          cancel: t\n        };\n      }\n    }\n    var he = ue;\n    const fe = function t(e) {\n      const r = new ce(e),\n        n = Object(mt.a)(ce.prototype.request, r);\n      return yt.a.extend(n, ce.prototype, r, {\n        allOwnKeys: !0\n      }), yt.a.extend(n, r, null, {\n        allOwnKeys: !0\n      }), n.create = function (r) {\n        return t(re(e, r));\n      }, n;\n    }(Lt);\n    fe.Axios = ce, fe.CanceledError = Ht, fe.CancelToken = he, fe.isCancel = zt, fe.VERSION = \"1.2.0\", fe.toFormData = gt.a, fe.AxiosError = kt.a, fe.Cancel = fe.CanceledError, fe.all = function (t) {\n      return Promise.all(t);\n    }, fe.spread = function (t) {\n      return function (e) {\n        return t.apply(null, e);\n      };\n    }, fe.isAxiosError = function (t) {\n      return yt.a.isObject(t) && !0 === t.isAxiosError;\n    }, fe.AxiosHeaders = qt, fe.formToJSON = t => jt(yt.a.isHTMLForm(t) ? new FormData(t) : t), fe.default = fe;\n    var le = fe;\n    function pe(t) {\n      return (pe = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function de(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, me(n.key), n);\n      }\n    }\n    function ye(t, e, r) {\n      return (e = me(e)) in t ? Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = r, t;\n    }\n    function me(t) {\n      var e = function (t, e) {\n        if (\"object\" !== pe(t) || null === t) return t;\n        var r = t[Symbol.toPrimitive];\n        if (void 0 !== r) {\n          var n = r.call(t, e || \"default\");\n          if (\"object\" !== pe(n)) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === e ? String : Number)(t);\n      }(t, \"string\");\n      return \"symbol\" === pe(e) ? e : String(e);\n    }\n    var ge = function () {\n        function t(e, r) {\n          var n = this;\n          !function (t, e) {\n            if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), ye(this, \"qrcode\", void 0), ye(this, \"device_status\", void 0), this.Socket = e, this.qrcode, this.device_status, this.all_info, this.token = r, this.Socket.on(\"qrcode\", function (t) {\n            n.qrcode = t;\n          }), this.Socket.on(\"device_status\", function (t) {\n            n.device_status = t;\n          });\n        }\n        var e, r, n;\n        return e = t, (r = [{\n          key: \"getCurrentQRCode\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              try {\n                t.Socket.emit(\"whatsapp:qrcode\", function (r) {\n                  t.qrcode = r, e(r);\n                });\n              } catch (t) {\n                console.error(\"Error to get current qrcode\", t), r(t);\n              }\n            });\n          }\n        }, {\n          key: \"getCurrentDeviceStatus\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              try {\n                t.Socket.emit(\"whatsapp:device_status\", function (r) {\n                  t.device_status = r, e(r);\n                });\n              } catch (t) {\n                console.error(\"Error to get current device status\", t), r(t);\n              }\n            });\n          }\n        }, {\n          key: \"getAllInfo\",\n          value: function () {\n            var t = this;\n            return new Promise(function (e, r) {\n              try {\n                var n = \"https://devices.wavoip.com/\".concat(t.token, \"/whatsapp/all_info\");\n                le.get(n, {\n                  headers: {\n                    Authorization: \"Bearer SEU_TOKEN_AQUI\",\n                    \"Content-Type\": \"application/json\"\n                  }\n                }).then(function (t) {\n                  e(t.data);\n                }).catch(function (t) {\n                  r(t);\n                });\n              } catch (t) {\n                console.error(\"Error to get current all infos\", t), r(t);\n              }\n            });\n          }\n        }]) && de(e.prototype, r), n && de(e, n), Object.defineProperty(e, \"prototype\", {\n          writable: !1\n        }), t;\n      }(),\n      ve = r(20),\n      be = r.n(ve);\n    function we(t) {\n      return (we = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function Ee() {\n      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */Ee = function () {\n        return t;\n      };\n      var t = {},\n        e = Object.prototype,\n        r = e.hasOwnProperty,\n        n = Object.defineProperty || function (t, e, r) {\n          t[e] = r.value;\n        },\n        o = \"function\" == typeof Symbol ? Symbol : {},\n        i = o.iterator || \"@@iterator\",\n        s = o.asyncIterator || \"@@asyncIterator\",\n        a = o.toStringTag || \"@@toStringTag\";\n      function c(t, e, r) {\n        return Object.defineProperty(t, e, {\n          value: r,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }), t[e];\n      }\n      try {\n        c({}, \"\");\n      } catch (t) {\n        c = function (t, e, r) {\n          return t[e] = r;\n        };\n      }\n      function u(t, e, r, o) {\n        var i = e && e.prototype instanceof l ? e : l,\n          s = Object.create(i.prototype),\n          a = new k(o || []);\n        return n(s, \"_invoke\", {\n          value: E(t, r, a)\n        }), s;\n      }\n      function h(t, e, r) {\n        try {\n          return {\n            type: \"normal\",\n            arg: t.call(e, r)\n          };\n        } catch (t) {\n          return {\n            type: \"throw\",\n            arg: t\n          };\n        }\n      }\n      t.wrap = u;\n      var f = {};\n      function l() {}\n      function p() {}\n      function d() {}\n      var y = {};\n      c(y, i, function () {\n        return this;\n      });\n      var m = Object.getPrototypeOf,\n        g = m && m(m(A([])));\n      g && g !== e && r.call(g, i) && (y = g);\n      var v = d.prototype = l.prototype = Object.create(y);\n      function b(t) {\n        [\"next\", \"throw\", \"return\"].forEach(function (e) {\n          c(t, e, function (t) {\n            return this._invoke(e, t);\n          });\n        });\n      }\n      function w(t, e) {\n        var o;\n        n(this, \"_invoke\", {\n          value: function (n, i) {\n            function s() {\n              return new e(function (o, s) {\n                !function n(o, i, s, a) {\n                  var c = h(t[o], t, i);\n                  if (\"throw\" !== c.type) {\n                    var u = c.arg,\n                      f = u.value;\n                    return f && \"object\" == we(f) && r.call(f, \"__await\") ? e.resolve(f.__await).then(function (t) {\n                      n(\"next\", t, s, a);\n                    }, function (t) {\n                      n(\"throw\", t, s, a);\n                    }) : e.resolve(f).then(function (t) {\n                      u.value = t, s(u);\n                    }, function (t) {\n                      return n(\"throw\", t, s, a);\n                    });\n                  }\n                  a(c.arg);\n                }(n, i, o, s);\n              });\n            }\n            return o = o ? o.then(s, s) : s();\n          }\n        });\n      }\n      function E(t, e, r) {\n        var n = \"suspendedStart\";\n        return function (o, i) {\n          if (\"executing\" === n) throw new Error(\"Generator is already running\");\n          if (\"completed\" === n) {\n            if (\"throw\" === o) throw i;\n            return R();\n          }\n          for (r.method = o, r.arg = i;;) {\n            var s = r.delegate;\n            if (s) {\n              var a = _(s, r);\n              if (a) {\n                if (a === f) continue;\n                return a;\n              }\n            }\n            if (\"next\" === r.method) r.sent = r._sent = r.arg;else if (\"throw\" === r.method) {\n              if (\"suspendedStart\" === n) throw n = \"completed\", r.arg;\n              r.dispatchException(r.arg);\n            } else \"return\" === r.method && r.abrupt(\"return\", r.arg);\n            n = \"executing\";\n            var c = h(t, e, r);\n            if (\"normal\" === c.type) {\n              if (n = r.done ? \"completed\" : \"suspendedYield\", c.arg === f) continue;\n              return {\n                value: c.arg,\n                done: r.done\n              };\n            }\n            \"throw\" === c.type && (n = \"completed\", r.method = \"throw\", r.arg = c.arg);\n          }\n        };\n      }\n      function _(t, e) {\n        var r = e.method,\n          n = t.iterator[r];\n        if (void 0 === n) return e.delegate = null, \"throw\" === r && t.iterator.return && (e.method = \"return\", e.arg = void 0, _(t, e), \"throw\" === e.method) || \"return\" !== r && (e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a '\" + r + \"' method\")), f;\n        var o = h(n, t.iterator, e.arg);\n        if (\"throw\" === o.type) return e.method = \"throw\", e.arg = o.arg, e.delegate = null, f;\n        var i = o.arg;\n        return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, \"return\" !== e.method && (e.method = \"next\", e.arg = void 0), e.delegate = null, f) : i : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, f);\n      }\n      function O(t) {\n        var e = {\n          tryLoc: t[0]\n        };\n        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n      }\n      function S(t) {\n        var e = t.completion || {};\n        e.type = \"normal\", delete e.arg, t.completion = e;\n      }\n      function k(t) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], t.forEach(O, this), this.reset(!0);\n      }\n      function A(t) {\n        if (t) {\n          var e = t[i];\n          if (e) return e.call(t);\n          if (\"function\" == typeof t.next) return t;\n          if (!isNaN(t.length)) {\n            var n = -1,\n              o = function e() {\n                for (; ++n < t.length;) if (r.call(t, n)) return e.value = t[n], e.done = !1, e;\n                return e.value = void 0, e.done = !0, e;\n              };\n            return o.next = o;\n          }\n        }\n        return {\n          next: R\n        };\n      }\n      function R() {\n        return {\n          value: void 0,\n          done: !0\n        };\n      }\n      return p.prototype = d, n(v, \"constructor\", {\n        value: d,\n        configurable: !0\n      }), n(d, \"constructor\", {\n        value: p,\n        configurable: !0\n      }), p.displayName = c(d, a, \"GeneratorFunction\"), t.isGeneratorFunction = function (t) {\n        var e = \"function\" == typeof t && t.constructor;\n        return !!e && (e === p || \"GeneratorFunction\" === (e.displayName || e.name));\n      }, t.mark = function (t) {\n        return Object.setPrototypeOf ? Object.setPrototypeOf(t, d) : (t.__proto__ = d, c(t, a, \"GeneratorFunction\")), t.prototype = Object.create(v), t;\n      }, t.awrap = function (t) {\n        return {\n          __await: t\n        };\n      }, b(w.prototype), c(w.prototype, s, function () {\n        return this;\n      }), t.AsyncIterator = w, t.async = function (e, r, n, o, i) {\n        void 0 === i && (i = Promise);\n        var s = new w(u(e, r, n, o), i);\n        return t.isGeneratorFunction(r) ? s : s.next().then(function (t) {\n          return t.done ? t.value : s.next();\n        });\n      }, b(v), c(v, a, \"Generator\"), c(v, i, function () {\n        return this;\n      }), c(v, \"toString\", function () {\n        return \"[object Generator]\";\n      }), t.keys = function (t) {\n        var e = Object(t),\n          r = [];\n        for (var n in e) r.push(n);\n        return r.reverse(), function t() {\n          for (; r.length;) {\n            var n = r.pop();\n            if (n in e) return t.value = n, t.done = !1, t;\n          }\n          return t.done = !0, t;\n        };\n      }, t.values = A, k.prototype = {\n        constructor: k,\n        reset: function (t) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = void 0, this.tryEntries.forEach(S), !t) for (var e in this) \"t\" === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0);\n        },\n        stop: function () {\n          this.done = !0;\n          var t = this.tryEntries[0].completion;\n          if (\"throw\" === t.type) throw t.arg;\n          return this.rval;\n        },\n        dispatchException: function (t) {\n          if (this.done) throw t;\n          var e = this;\n          function n(r, n) {\n            return s.type = \"throw\", s.arg = t, e.next = r, n && (e.method = \"next\", e.arg = void 0), !!n;\n          }\n          for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n            var i = this.tryEntries[o],\n              s = i.completion;\n            if (\"root\" === i.tryLoc) return n(\"end\");\n            if (i.tryLoc <= this.prev) {\n              var a = r.call(i, \"catchLoc\"),\n                c = r.call(i, \"finallyLoc\");\n              if (a && c) {\n                if (this.prev < i.catchLoc) return n(i.catchLoc, !0);\n                if (this.prev < i.finallyLoc) return n(i.finallyLoc);\n              } else if (a) {\n                if (this.prev < i.catchLoc) return n(i.catchLoc, !0);\n              } else {\n                if (!c) throw new Error(\"try statement without catch or finally\");\n                if (this.prev < i.finallyLoc) return n(i.finallyLoc);\n              }\n            }\n          }\n        },\n        abrupt: function (t, e) {\n          for (var n = this.tryEntries.length - 1; n >= 0; --n) {\n            var o = this.tryEntries[n];\n            if (o.tryLoc <= this.prev && r.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n              var i = o;\n              break;\n            }\n          }\n          i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n          var s = i ? i.completion : {};\n          return s.type = t, s.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, f) : this.complete(s);\n        },\n        complete: function (t, e) {\n          if (\"throw\" === t.type) throw t.arg;\n          return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), f;\n        },\n        finish: function (t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), S(r), f;\n          }\n        },\n        catch: function (t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.tryLoc === t) {\n              var n = r.completion;\n              if (\"throw\" === n.type) {\n                var o = n.arg;\n                S(r);\n              }\n              return o;\n            }\n          }\n          throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function (t, e, r) {\n          return this.delegate = {\n            iterator: A(t),\n            resultName: e,\n            nextLoc: r\n          }, \"next\" === this.method && (this.arg = void 0), f;\n        }\n      }, t;\n    }\n    function _e(t, e, r, n, o, i, s) {\n      try {\n        var a = t[i](s),\n          c = a.value;\n      } catch (t) {\n        return void r(t);\n      }\n      a.done ? e(c) : Promise.resolve(c).then(n, o);\n    }\n    function Oe(t) {\n      return function () {\n        var e = this,\n          r = arguments;\n        return new Promise(function (n, o) {\n          var i = t.apply(e, r);\n          function s(t) {\n            _e(i, n, o, s, a, \"next\", t);\n          }\n          function a(t) {\n            _e(i, n, o, s, a, \"throw\", t);\n          }\n          s(void 0);\n        });\n      };\n    }\n    var Se,\n      ke,\n      Ae,\n      Re,\n      xe,\n      Te = [];\n    function Pe() {\n      return (Pe = Oe(Ee().mark(function t(e, r, n) {\n        return Ee().wrap(function (t) {\n          for (;;) switch (t.prev = t.next) {\n            case 0:\n              Se = e, xe = n;\n            case 2:\n            case \"end\":\n              return t.stop();\n          }\n        }, t);\n      }))).apply(this, arguments);\n    }\n    document.addEventListener(\"click\", function () {\n      ke && ke.resume().catch(function () {\n        console.error(\"[*] - Error to get microphone access\");\n      });\n    });\n    var je = function () {\n        var t = Oe(Ee().mark(function t() {\n          var e, r;\n          return Ee().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                return ke || (ke = new (window.AudioContext || window.webkitAudioContext)()), t.next = 3, ke.audioWorklet.addModule(be.a);\n              case 3:\n                return t.next = 5, ke.audioWorklet.addModule(\"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js/dist/libsamplerate.worklet.js\");\n              case 5:\n                return xe.emit(\"microphone_audioctx_change_state\", {\n                  audio_context: ke,\n                  state: null === (e = ke) || void 0 === e ? void 0 : e.state\n                }), ke.onstatechange = function () {\n                  var t;\n                  xe.emit(\"microphone_audioctx_change_state\", {\n                    audio_context: ke,\n                    state: null === (t = ke) || void 0 === t ? void 0 : t.state\n                  });\n                }, t.next = 9, navigator.mediaDevices.getUserMedia({\n                  audio: !0\n                });\n              case 9:\n                Ae = t.sent, Re = ke.createMediaStreamSource(Ae), (r = new AudioWorkletNode(ke, \"resample-processor\", {\n                  processorOptions: {\n                    sampleRate: ke.sampleRate\n                  }\n                })).port.onmessage = function (t) {\n                  Se.socket_audio_transport.volatile.timeout(250).emit(\"microphone_buffer\", t.data);\n                }, Re.connect(r);\n              case 14:\n              case \"end\":\n                return t.stop();\n            }\n          }, t);\n        }));\n        return function () {\n          return t.apply(this, arguments);\n        };\n      }(),\n      Ce = function () {\n        var t = Oe(Ee().mark(function t() {\n          return Ee().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                Re && (Re.disconnect(), Re = null), Ae && (Ae.getTracks().forEach(function (t) {\n                  return t.stop();\n                }), Ae = null), ke && (ke.close(), ke = null), console.log(\"Microfone desconectado e stream parado.\");\n              case 5:\n              case \"end\":\n                return t.stop();\n            }\n          }, t);\n        }));\n        return function () {\n          return t.apply(this, arguments);\n        };\n      }();\n    function Be() {\n      return Le.apply(this, arguments);\n    }\n    function Le() {\n      return (Le = Oe(Ee().mark(function t() {\n        var e;\n        return Ee().wrap(function (t) {\n          for (;;) switch (t.prev = t.next) {\n            case 0:\n              return t.prev = 0, t.next = 3, navigator.mediaDevices.enumerateDevices();\n            case 3:\n              e = t.sent, Te = e.filter(function (t) {\n                return \"audioinput\" === t.kind;\n              }).map(function (t) {\n                return {\n                  label: t.label || \"Unnamed Microphone\",\n                  deviceId: t.deviceId\n                };\n              }), console.log(\"Microphones updated:\", Te), t.next = 11;\n              break;\n            case 8:\n              t.prev = 8, t.t0 = t.catch(0), console.error(\"Error fetching microphones:\", t.t0);\n            case 11:\n            case \"end\":\n              return t.stop();\n          }\n        }, t, null, [[0, 8]]);\n      }))).apply(this, arguments);\n    }\n    function Ne() {\n      return Ue.apply(this, arguments);\n    }\n    function Ue() {\n      return (Ue = Oe(Ee().mark(function t() {\n        var e;\n        return Ee().wrap(function (t) {\n          for (;;) switch (t.prev = t.next) {\n            case 0:\n              return t.prev = 0, t.next = 3, navigator.mediaDevices.getUserMedia({\n                audio: !0\n              });\n            case 3:\n              e = t.sent, console.log(\"Permisso concedida para o microfone.\"), e.getTracks().forEach(function (t) {\n                return t.stop();\n              }), t.next = 11;\n              break;\n            case 8:\n              t.prev = 8, t.t0 = t.catch(0), \"NotAllowedError\" === t.t0.name ? console.log(\"Permisso para o microfone foi negada.\") : \"NotFoundError\" === t.t0.name ? console.log(\"Nenhum microfone disponvel no dispositivo.\") : console.error(\"Erro ao solicitar permisso para o microfone:\", t.t0);\n            case 11:\n            case \"end\":\n              return t.stop();\n          }\n        }, t, null, [[0, 8]]);\n      }))).apply(this, arguments);\n    }\n    function De() {\n      return Me.apply(this, arguments);\n    }\n    function Me() {\n      return (Me = Oe(Ee().mark(function t() {\n        var e;\n        return Ee().wrap(function (t) {\n          for (;;) switch (t.prev = t.next) {\n            case 0:\n              return t.prev = 0, t.next = 3, navigator.permissions.query({\n                name: \"microphone\"\n              });\n            case 3:\n              e = t.sent, t.t0 = e.state, t.next = \"granted\" === t.t0 ? 7 : \"denied\" === t.t0 ? 9 : \"prompt\" === t.t0 ? 11 : 14;\n              break;\n            case 7:\n              return console.log(\"Permisso concedida para o microfone.\"), t.abrupt(\"break\", 14);\n            case 9:\n              return console.log(\"Permisso negada para o microfone.\"), t.abrupt(\"break\", 14);\n            case 11:\n              return t.next = 13, Ne();\n            case 13:\n              return t.abrupt(\"break\", 14);\n            case 14:\n              return t.abrupt(\"return\", e.state);\n            case 17:\n              return t.prev = 17, t.t1 = t.catch(0), console.error(\"Erro ao verificar permisso:\", t.t1), t.abrupt(\"return\", !1);\n            case 21:\n            case \"end\":\n              return t.stop();\n          }\n        }, t, null, [[0, 17]]);\n      }))).apply(this, arguments);\n    }\n    function Ie() {\n      return (Ie = Oe(Ee().mark(function t() {\n        var e, r;\n        return Ee().wrap(function (t) {\n          for (;;) switch (t.prev = t.next) {\n            case 0:\n              return t.next = 2, De();\n            case 2:\n              if (r = t.sent, 0 !== Te.length) {\n                t.next = 7;\n                break;\n              }\n              return t.abrupt(\"return\", {\n                type: \"no_microphone_available\",\n                message: \"No h microfone disponivel para uso\"\n              });\n            case 7:\n              if (\"granted\" === r) {\n                t.next = 11;\n                break;\n              }\n              return t.abrupt(\"return\", {\n                type: \"no_microphone_permission\",\n                message: \"Sem permisso para acessar o microfone\"\n              });\n            case 11:\n              if (!ke || \"running\" === ke.state) {\n                t.next = 15;\n                break;\n              }\n              return t.abrupt(\"return\", {\n                type: \"audio_context\",\n                message: \"No foi possvel obter acesso ao microfone\"\n              });\n            case 15:\n              if (!navigator.userActivation.hasBeenActive || \"running\" === (null === (e = ke) || void 0 === e ? void 0 : e.state)) {\n                t.next = 19;\n                break;\n              }\n              return t.abrupt(\"return\", {\n                type: \"audio_context\",\n                message: \"Voc precisa interagir com a pgina para liberar a permisso do microfone\"\n              });\n            case 19:\n              return console.log(\"[MICROPHONE] - Permission success to access microphone device\"), t.abrupt(\"return\", !1);\n            case 21:\n            case \"end\":\n              return t.stop();\n          }\n        }, t);\n      }))).apply(this, arguments);\n    }\n    Be(), navigator.mediaDevices.addEventListener(\"devicechange\", Be);\n    var Fe = {\n      init: function (t, e, r) {\n        return Pe.apply(this, arguments);\n      },\n      start: je,\n      stop: Ce,\n      requestMicrophonePermission: Ne,\n      checkMicrophonePermission: De,\n      fetchMicrophones: Be,\n      getMicrophones: function () {\n        return Te;\n      },\n      getAudioContext: function () {\n        return ke;\n      },\n      checkError: function () {\n        return Ie.apply(this, arguments);\n      }\n    };\n    function qe(t) {\n      return (qe = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function Ye(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, (o = n.key, i = void 0, i = function (t, e) {\n          if (\"object\" !== qe(t) || null === t) return t;\n          var r = t[Symbol.toPrimitive];\n          if (void 0 !== r) {\n            var n = r.call(t, e || \"default\");\n            if (\"object\" !== qe(n)) return n;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n          }\n          return (\"string\" === e ? String : Number)(t);\n        }(o, \"string\"), \"symbol\" === qe(i) ? i : String(i)), n);\n      }\n      var o, i;\n    }\n    var ze = function () {\n      function t() {\n        !function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, t), this.events = {};\n      }\n      var e, r, n;\n      return e = t, (r = [{\n        key: \"on\",\n        value: function (t, e) {\n          this.events[t] || (this.events[t] = []), this.events[t].push(e);\n        }\n      }, {\n        key: \"emit\",\n        value: function (t) {\n          for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];\n          this.events[t] && this.events[t].forEach(function (t) {\n            return t.apply(void 0, r);\n          });\n        }\n      }, {\n        key: \"off\",\n        value: function (t, e) {\n          this.events[t] && (this.events[t] = this.events[t].filter(function (t) {\n            return t !== e;\n          }));\n        }\n      }]) && Ye(e.prototype, r), n && Ye(e, n), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n      }), t;\n    }();\n    function Ve(t) {\n      return (Ve = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n    function He(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, We(n.key), n);\n      }\n    }\n    function Ke(t, e, r) {\n      return e && He(t.prototype, e), r && He(t, r), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), t;\n    }\n    function We(t) {\n      var e = function (t, e) {\n        if (\"object\" !== Ve(t) || null === t) return t;\n        var r = t[Symbol.toPrimitive];\n        if (void 0 !== r) {\n          var n = r.call(t, e || \"default\");\n          if (\"object\" !== Ve(n)) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === e ? String : Number)(t);\n      }(t, \"string\");\n      return \"symbol\" === Ve(e) ? e : String(e);\n    }\n    var Je = Ke(function t() {\n      var e, r, n;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), e = this, n = function (t) {\n        var e = new K(t),\n          r = new ze(),\n          n = new dt(e, r),\n          o = new Q(e.socket),\n          i = new ge(e.socket, t);\n        Fe.init(e, 16e3, r), e.socket.on(\"connect\", function () {}), e.socket.on(\"disconnect\", function (t) {}), e.socket.on(\"signaling\", function (t) {}), e.socket.on(\"audio_transport:create\", function (t) {\n          var o = t.room;\n          t.sampleRate, n.start(16e3, o), Fe.init(e, 16e3, r), Fe.start();\n        }), e.socket.on(\"audio_transport:terminate\", function (t) {\n          t.room, n.stop(), Fe.stop();\n        });\n        var s = {\n          socket: e.socket,\n          getCurrentDeviceStatus: function () {\n            return i.getCurrentDeviceStatus();\n          },\n          getCurrentQRCode: function () {\n            return i.getCurrentQRCode();\n          },\n          getAllInfo: function () {\n            return i.getAllInfo();\n          },\n          callStart: function (t) {\n            return n.checkError(), o.callStart(t);\n          },\n          endCall: function () {\n            return o.endCall();\n          },\n          acceptCall: function () {\n            return o.acceptCall();\n          },\n          rejectCall: function () {\n            return o.rejectCall();\n          },\n          mute: function () {\n            return o.mute();\n          },\n          unMute: function () {\n            return o.unMute();\n          },\n          Microphone: Fe,\n          Audio: n,\n          deviceEmitter: r\n        };\n        return window.wavoip_api || (window.wavoip_api = {}), window.wavoip_api[t] = s, s;\n      }, (r = We(r = \"connect\")) in e ? Object.defineProperty(e, r, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[r] = n;\n    });\n    e.default = Je;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}