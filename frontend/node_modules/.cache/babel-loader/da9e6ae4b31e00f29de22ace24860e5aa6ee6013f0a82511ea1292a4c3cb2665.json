{"ast":null,"code":"/**\n * Converts indexed data into RGB/RGBA format\n * @param decodedImage - Image to decode data from.\n * @returns Uint8Array with RGB data.\n */\nexport function convertIndexedToRgb(decodedImage) {\n  const palette = decodedImage.palette;\n  const depth = decodedImage.depth;\n  if (!palette) {\n    throw new Error('Color palette is undefined.');\n  }\n  checkDataSize(decodedImage);\n  const indexSize = decodedImage.width * decodedImage.height;\n  const resSize = indexSize * palette[0].length;\n  const res = new Uint8Array(resSize);\n  let indexPos = 0;\n  let offset = 0;\n  const indexes = new Uint8Array(indexSize);\n  let bit = 0xff;\n  switch (depth) {\n    case 1:\n      bit = 0x80;\n      break;\n    case 2:\n      bit = 0xc0;\n      break;\n    case 4:\n      bit = 0xf0;\n      break;\n    case 8:\n      bit = 0xff;\n      break;\n    default:\n      throw new Error('Incorrect depth value');\n  }\n  for (const byte of decodedImage.data) {\n    let bit2 = bit;\n    let shift = 8;\n    while (bit2) {\n      shift -= depth;\n      indexes[indexPos++] = (byte & bit2) >> shift;\n      bit2 = bit2 >> depth;\n      if (indexPos % decodedImage.width === 0) {\n        break;\n      }\n    }\n  }\n  if (decodedImage.palette) {\n    for (const index of indexes) {\n      const color = decodedImage.palette.at(index);\n      if (!color) {\n        throw new Error('Incorrect index of palette color');\n      }\n      res.set(color, offset);\n      offset += color.length;\n    }\n  }\n  return res;\n}\nfunction checkDataSize(image) {\n  const expectedSize = image.depth < 8 ? Math.ceil(image.width * image.depth / 8) * image.height * image.channels : image.width * image.height * image.channels;\n  if (image.data.length !== expectedSize) {\n    throw new RangeError(\"wrong data size. Found \".concat(image.data.length, \", expected \").concat(expectedSize));\n  }\n}","map":{"version":3,"names":["convertIndexedToRgb","decodedImage","palette","depth","Error","checkDataSize","indexSize","width","height","resSize","length","res","Uint8Array","indexPos","offset","indexes","bit","byte","data","bit2","shift","index","color","at","set","image","expectedSize","Math","ceil","channels","RangeError","concat"],"sources":["/home/deploy/atendechatop/frontend/node_modules/fast-png/src/convertIndexedToRgb.ts"],"sourcesContent":["import type { DecodedPng, IndexedColorBitDepth } from './types';\n\n/**\n * Converts indexed data into RGB/RGBA format\n * @param decodedImage - Image to decode data from.\n * @returns Uint8Array with RGB data.\n */\nexport function convertIndexedToRgb(decodedImage: DecodedPng) {\n  const palette = decodedImage.palette;\n  const depth = decodedImage.depth as IndexedColorBitDepth;\n  if (!palette) {\n    throw new Error('Color palette is undefined.');\n  }\n  checkDataSize(decodedImage);\n  const indexSize = decodedImage.width * decodedImage.height;\n  const resSize = indexSize * palette[0].length;\n  const res = new Uint8Array(resSize);\n  let indexPos = 0;\n  let offset = 0;\n  const indexes = new Uint8Array(indexSize);\n  let bit = 0xff;\n  switch (depth) {\n    case 1:\n      bit = 0x80;\n      break;\n    case 2:\n      bit = 0xc0;\n      break;\n    case 4:\n      bit = 0xf0;\n      break;\n    case 8:\n      bit = 0xff;\n      break;\n    default:\n      throw new Error('Incorrect depth value');\n  }\n  for (const byte of decodedImage.data) {\n    let bit2 = bit;\n    let shift = 8;\n    while (bit2) {\n      shift -= depth;\n      indexes[indexPos++] = (byte & bit2) >> shift;\n\n      bit2 = bit2 >> depth;\n      if (indexPos % decodedImage.width === 0) {\n        break;\n      }\n    }\n  }\n\n  if (decodedImage.palette) {\n    for (const index of indexes) {\n      const color = decodedImage.palette.at(index);\n      if (!color) {\n        throw new Error('Incorrect index of palette color');\n      }\n      res.set(color, offset);\n      offset += color.length;\n    }\n  }\n  return res;\n}\n\nfunction checkDataSize(image: DecodedPng): void {\n  const expectedSize =\n    image.depth < 8\n      ? Math.ceil((image.width * image.depth) / 8) *\n        image.height *\n        image.channels\n      : image.width * image.height * image.channels;\n\n  if (image.data.length !== expectedSize) {\n    throw new RangeError(\n      `wrong data size. Found ${image.data.length}, expected ${expectedSize}`,\n    );\n  }\n}\n"],"mappings":"AAEA;;;;;AAKA,OAAM,SAAUA,mBAAmBA,CAACC,YAAwB;EAC1D,MAAMC,OAAO,GAAGD,YAAY,CAACC,OAAO;EACpC,MAAMC,KAAK,GAAGF,YAAY,CAACE,KAA6B;EACxD,IAAI,CAACD,OAAO,EAAE;IACZ,MAAM,IAAIE,KAAK,CAAC,6BAA6B,CAAC;EAChD;EACAC,aAAa,CAACJ,YAAY,CAAC;EAC3B,MAAMK,SAAS,GAAGL,YAAY,CAACM,KAAK,GAAGN,YAAY,CAACO,MAAM;EAC1D,MAAMC,OAAO,GAAGH,SAAS,GAAGJ,OAAO,CAAC,CAAC,CAAC,CAACQ,MAAM;EAC7C,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAACH,OAAO,CAAC;EACnC,IAAII,QAAQ,GAAG,CAAC;EAChB,IAAIC,MAAM,GAAG,CAAC;EACd,MAAMC,OAAO,GAAG,IAAIH,UAAU,CAACN,SAAS,CAAC;EACzC,IAAIU,GAAG,GAAG,IAAI;EACd,QAAQb,KAAK;IACX,KAAK,CAAC;MACJa,GAAG,GAAG,IAAI;MACV;IACF,KAAK,CAAC;MACJA,GAAG,GAAG,IAAI;MACV;IACF,KAAK,CAAC;MACJA,GAAG,GAAG,IAAI;MACV;IACF,KAAK,CAAC;MACJA,GAAG,GAAG,IAAI;MACV;IACF;MACE,MAAM,IAAIZ,KAAK,CAAC,uBAAuB,CAAC;EAC5C;EACA,KAAK,MAAMa,IAAI,IAAIhB,YAAY,CAACiB,IAAI,EAAE;IACpC,IAAIC,IAAI,GAAGH,GAAG;IACd,IAAII,KAAK,GAAG,CAAC;IACb,OAAOD,IAAI,EAAE;MACXC,KAAK,IAAIjB,KAAK;MACdY,OAAO,CAACF,QAAQ,EAAE,CAAC,GAAG,CAACI,IAAI,GAAGE,IAAI,KAAKC,KAAK;MAE5CD,IAAI,GAAGA,IAAI,IAAIhB,KAAK;MACpB,IAAIU,QAAQ,GAAGZ,YAAY,CAACM,KAAK,KAAK,CAAC,EAAE;QACvC;MACF;IACF;EACF;EAEA,IAAIN,YAAY,CAACC,OAAO,EAAE;IACxB,KAAK,MAAMmB,KAAK,IAAIN,OAAO,EAAE;MAC3B,MAAMO,KAAK,GAAGrB,YAAY,CAACC,OAAO,CAACqB,EAAE,CAACF,KAAK,CAAC;MAC5C,IAAI,CAACC,KAAK,EAAE;QACV,MAAM,IAAIlB,KAAK,CAAC,kCAAkC,CAAC;MACrD;MACAO,GAAG,CAACa,GAAG,CAACF,KAAK,EAAER,MAAM,CAAC;MACtBA,MAAM,IAAIQ,KAAK,CAACZ,MAAM;IACxB;EACF;EACA,OAAOC,GAAG;AACZ;AAEA,SAASN,aAAaA,CAACoB,KAAiB;EACtC,MAAMC,YAAY,GAChBD,KAAK,CAACtB,KAAK,GAAG,CAAC,GACXwB,IAAI,CAACC,IAAI,CAAEH,KAAK,CAAClB,KAAK,GAAGkB,KAAK,CAACtB,KAAK,GAAI,CAAC,CAAC,GAC1CsB,KAAK,CAACjB,MAAM,GACZiB,KAAK,CAACI,QAAQ,GACdJ,KAAK,CAAClB,KAAK,GAAGkB,KAAK,CAACjB,MAAM,GAAGiB,KAAK,CAACI,QAAQ;EAEjD,IAAIJ,KAAK,CAACP,IAAI,CAACR,MAAM,KAAKgB,YAAY,EAAE;IACtC,MAAM,IAAII,UAAU,2BAAAC,MAAA,CACQN,KAAK,CAACP,IAAI,CAACR,MAAM,iBAAAqB,MAAA,CAAcL,YAAY,CAAE,CACxE;EACH;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}